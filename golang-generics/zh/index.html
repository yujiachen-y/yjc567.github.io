<!doctype html>
<html lang="zh" data-theme="auto">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Golang 泛型 | Jiachen Yu</title>
        <meta name="description" content="Golang 泛型" />
    <meta property="og:title" content="Golang 泛型 | Jiachen Yu" />
    <meta property="og:description" content="Golang 泛型" />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://www.yujiachen.com/golang-generics/zh/" />
    <meta name="twitter:card" content="summary" />
    <link rel="canonical" href="https://www.yujiachen.com/golang-generics/zh/" />
    <link rel="alternate" type="text/markdown" href="https://www.yujiachen.com/posts/golang-generics/post.md" />
    <link rel="alternate" hreflang="en" href="https://www.yujiachen.com/golang-generics/" />
<link rel="alternate" hreflang="zh" href="https://www.yujiachen.com/golang-generics/zh/" /> <link rel="alternate" type="application/rss+xml" title="RSS" href="https://www.yujiachen.com/rss.xml" />
<link rel="alternate" type="application/rss+xml" title="RSS (ZH)" href="https://www.yujiachen.com/rss-zh.xml" /> <link rel="icon" href="/favicon-32.png" type="image/png" sizes="32x32" />
<link rel="icon" href="/favicon.png" type="image/png" />
<link rel="icon" href="/favicon.ico" type="image/x-icon" />
<link rel="apple-touch-icon" href="/apple-touch-icon.png" sizes="180x180" /> <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&amp;family=Source+Serif+4:ital,wght@0,400;0,600;0,700;1,400&amp;family=Noto+Serif+SC:wght@400;600;700&amp;display=swap" />
    <link rel="stylesheet" href="/katex/katex.min.css" />
    <link rel="stylesheet" href="/styles.css" />
    <link rel="stylesheet" href="/fonts.css" />
  </head>
  <body data-page="post">
    <div id="root">
      
<nav class="navbar">
  <div class="nav-left">
    <a href="/zh/" class="brand">Jiachen Yu</a>
    <div class="nav-links">
      <a class="nav-link-button" href="/about/zh/" data-nav="about">About</a>
      <a class="nav-link-button" href="/blog/zh/" data-nav="blog">Blog</a>
    </div>
  </div>
  <div class="controls">
    <div class="action-controls">
      <div class="lang-switcher" data-lang-switcher data-lang-switcher-mode="toggle">
        <button class="lang-toggle" type="button" data-lang-toggle>EN</button>
      </div>
      <div class="theme-switcher" data-theme-switcher data-theme-state="light">
        <button
          class="theme-trigger"
          type="button"
          data-theme-trigger
          aria-label="Theme mode toggle"
          aria-pressed="false"
        >
          <span class="theme-trigger-icon">
            <svg class="theme-icon theme-icon-dark" viewBox="0 0 24 24" aria-hidden="true">
              <path
                d="M21 12.8A8.5 8.5 0 1 1 11.2 3a7.5 7.5 0 0 0 9.8 9.8Z"
                fill="currentColor"
              />
            </svg>
            <svg class="theme-icon theme-icon-light" viewBox="0 0 24 24" aria-hidden="true">
              <circle cx="12" cy="12" r="4" fill="currentColor" />
              <path
                d="M12 3v2M12 19v2M4.9 4.9l1.4 1.4M17.7 17.7l1.4 1.4M3 12h2M19 12h2M4.9 19.1l1.4-1.4M17.7 6.3l1.4-1.4"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                fill="none"
              />
            </svg>
          </span>
        </button>
      </div>
      <a
        class="ask-ai-entry"
        href="/ask-ai/"
        data-ask-ai-entry
        aria-label="Open Ask AI"
      >
        <span class="ask-ai-entry-label">Ask AI</span>
      </a>
    </div>
  </div>
</nav>

      <main class="page-shell article-page">
        <div class="article-layout has-toc page-shell-content">
          
    <aside class="article-toc sidebar-panel" data-toc>
      <button class="toc-toggle sidebar-toggle" type="button" data-toc-toggle aria-expanded="false">
        <span class="toc-toggle-label">目录</span>
        <span class="toc-toggle-icon" aria-hidden="true">⌄</span>
      </button>
      <div class="toc-panel sidebar-panel-content" data-toc-panel>
        <div class="toc-title sidebar-title">目录</div>
        <ol class="toc-list sidebar-list">
      <li class="toc-item sidebar-item toc-level-1"><a class="sidebar-link" href="#名词解释">名词解释</a></li>
      <li class="toc-item sidebar-item toc-level-1"><a class="sidebar-link" href="#总览">总览</a></li>
      <li class="toc-item sidebar-item toc-level-1"><a class="sidebar-link" href="#类型约束">类型约束</a></li>
      <li class="toc-item sidebar-item toc-level-2"><a class="sidebar-link" href="#underlying-type">Underlying type</a></li>
      <li class="toc-item sidebar-item toc-level-2"><a class="sidebar-link" href="#使用-type-parameter-和直接使用-interface-的区别">使用 type parameter 和直接使用 interface 的区别</a></li>
      <li class="toc-item sidebar-item toc-level-1"><a class="sidebar-link" href="#类型推断">类型推断</a></li>
      <li class="toc-item sidebar-item toc-level-2"><a class="sidebar-link" href="#类型归一化-type-unification">类型归一化 ( Type unification )</a></li>
      <li class="toc-item sidebar-item toc-level-3"><a class="sidebar-link" href="#功能描述">功能描述</a></li>
      <li class="toc-item sidebar-item toc-level-3"><a class="sidebar-link" href="#具体操作">具体操作</a></li>
      <li class="toc-item sidebar-item toc-level-2"><a class="sidebar-link" href="#函数实参类型推断-function-argument-type-inference">函数实参类型推断 ( Function argument type inference )</a></li>
      <li class="toc-item sidebar-item toc-level-3"><a class="sidebar-link" href="#功能描述-2">功能描述</a></li>
      <li class="toc-item sidebar-item toc-level-3"><a class="sidebar-link" href="#具体实现">具体实现</a></li>
      <li class="toc-item sidebar-item toc-level-2"><a class="sidebar-link" href="#约束类型推断-constraint-type-inference">约束类型推断 ( Constraint type inference )</a></li>
      <li class="toc-item sidebar-item toc-level-3"><a class="sidebar-link" href="#功能描述-3">功能描述</a></li>
      <li class="toc-item sidebar-item toc-level-3"><a class="sidebar-link" href="#具体实现-2">具体实现</a></li>
      <li class="toc-item sidebar-item toc-level-2"><a class="sidebar-link" href="#类型推断执行步骤">类型推断执行步骤</a></li>
      <li class="toc-item sidebar-item toc-level-1"><a class="sidebar-link" href="#其他">其他</a></li>
      <li class="toc-item sidebar-item toc-level-2"><a class="sidebar-link" href="#泛型窘境">泛型窘境</a></li>
      <li class="toc-item sidebar-item toc-level-2"><a class="sidebar-link" href="#使用-t-而不是-t">使用 [T] 而不是 &lt;T&gt;</a></li>
      <li class="toc-item sidebar-item toc-level-2"><a class="sidebar-link" href="#为何-go-泛型不支持-method">为何 Go 泛型不支持 method？</a></li>
      <li class="toc-item sidebar-item toc-level-2"><a class="sidebar-link" href="#支持指针方法">支持指针方法</a></li>
      <li class="toc-item sidebar-item toc-level-2"><a class="sidebar-link" href="#在工作中使用泛型">在工作中使用泛型</a></li>
      <li class="toc-item sidebar-item toc-level-1"><a class="sidebar-link" href="#类型推断代码">类型推断代码</a></li>
      <li class="toc-item sidebar-item toc-level-2"><a class="sidebar-link" href="#类型归一化">类型归一化</a></li>
      <li class="toc-item sidebar-item toc-level-2"><a class="sidebar-link" href="#函数实参类型推断">函数实参类型推断</a></li>
      <li class="toc-item sidebar-item toc-level-3"><a class="sidebar-link" href="#有类型的实参直接归一化">有类型的实参直接归一化</a></li>
      <li class="toc-item sidebar-item toc-level-3"><a class="sidebar-link" href="#没有类型的实参赋予常量默认值后归一化">没有类型的实参赋予常量默认值后归一化</a></li>
      <li class="toc-item sidebar-item toc-level-2"><a class="sidebar-link" href="#约束类型推断">约束类型推断</a></li>
      <li class="toc-item sidebar-item toc-level-3"><a class="sidebar-link" href="#类型参数-core-type-处理">类型参数 core type 处理</a></li>
      <li class="toc-item sidebar-item toc-level-3"><a class="sidebar-link" href="#映射关系化简">映射关系化简</a></li>
        </ol>
      </div>
    </aside>
  
          <div class="article-content">
            

<div class="article-text-content">
  <div class="article-date">2023-05-26 · TECH</div>
  <h1 class="article-hero">Golang 泛型</h1>
  <div class="article-body"><p>泛型是一种编程范式，允许在编写代码时使用通用的类型，从而提高代码的复用性和灵活性。在许多编程语言（如 Java、C++ 和 C#）中，泛型已经成为一种非常重要的特性，使得开发者能够编写更加通用、灵活且类型安全的代码。然而，Go 语言在最初的设计中并没有包含泛型特性，这导致了一些局限性和不便。随着 Go 语言的发展，为了使其更加完善，并满足开发者在实际工作中的需求，Go 语言社区逐渐引入了泛型特性。通过引入泛型，Go 语言能够实现更加通用的数据结构和函数，从而提高开发效率和代码质量。</p>
<p>举个例子：</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;golang.org/x/exp/constraints&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GMin</span>[<span class="hljs-title">T</span> <span class="hljs-title">constraints</span>.<span class="hljs-title">Ordered</span>]<span class="hljs-params">(x, y T)</span></span> T {
    <span class="hljs-keyword">if</span> x &lt; y {
        <span class="hljs-keyword">return</span> x
    }
    <span class="hljs-keyword">return</span> y
}

</code></pre>
<p>不过 Go 泛型和其他语言的泛型略有不同，本文从 Go 的类型参数提案出发，结合实现代码和示例，说明 Go 泛型的一些特性，期望可以达到让大家在工作中更好更高效使用泛型的目的。</p>
<blockquote>
<p>主要参考：<a href="https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md">https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md</a></p>
</blockquote>
<h1 id="名词解释">名词解释</h1>
<ul>
<li>parameter，也被称作形参，指函数定义时指定需要传入的参数，实际上是一个占位符，没有真实值，例如 <code>func Add(a, b int) int</code> 中的 <code>a</code> 和 <code>b</code> 。下文用类型参数指代，例如 <code>func Add[T any](a, b T) T</code> 中的 <code>T</code> 就是 type parameter 类型参数。</li>
<li>argument，也被称作实参，指函数被调用时实际传入的参数，是一个真实值，例如 <code>sum := Add[int](a, 2)</code> 中的 <code>a</code> 和 <code>2</code>，此示例中 <code>a</code> 是一个命名变量或常量，2 是一个未命名常量。下文用类型实参，例子中 <code>Add[int]</code> 中的 <code>int</code> 就是 type argument 类型实参。</li>
<li>function，指 Golang 中的函数，如 <code>func Add(a, b int) int</code>。<a href="https://go.dev/ref/spec#Function_types">https://go.dev/ref/spec#Function_types</a></li>
<li>method，指 Golang 中结构体的方法，如 <code>func (s *Struct) Get() string</code>。<a href="https://go.dev/ref/spec#Method_declarations">https://go.dev/ref/spec#Method_declarations</a></li>
<li>operation，可以理解为 Golang 中内置类型支持的运算符（见下），Go spec 中使用 operator 这个名词。<a href="https://go.dev/ref/spec#Operators">https://go.dev/ref/spec#Operators</a></li>
</ul>
<pre class="hljs"><code>Expression = UnaryExpr | Expression binary_op Expression .
UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

binary_op  = &quot;||&quot; | &quot;&amp;&amp;&quot; | rel_op | add_op | mul_op .
rel_op     = &quot;==&quot; | &quot;!=&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;&gt;&quot; | &quot;&gt;=&quot; .
add_op     = &quot;+&quot; | &quot;-&quot; | &quot;|&quot; | &quot;^&quot; .
mul_op     = &quot;*&quot; | &quot;/&quot; | &quot;%&quot; | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; | &quot;&amp;&quot; | &quot;&amp;^&quot; .

unary_op   = &quot;+&quot; | &quot;-&quot; | &quot;!&quot; | &quot;^&quot; | &quot;*&quot; | &quot;&amp;&quot; | &quot;&lt;-&quot; .

</code></pre>
<h1 id="总览">总览</h1>
<p>Go 类型参数提案归纳了 Go 类型参数的几个要点（<a href="https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#summary%EF%BC%89%EF%BC%9A">https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#summary）：</a></p>
<ul>
<li>函数和类型可以有类型参数，类型参数由类型约束定义，类型约束的类型为 interface。(注意，这里没有提及方法，也就是说方法不可以有类型参数）</li>
<li>类型约束描述了 type argument，即传入的实参需要实现的方法，和允许传入实参的类型。</li>
<li>类型约束描述了 type parameter，即定义的形参支持的方法和运算符。</li>
<li>当调用支持类型参数的函数时，类型推断有时可以推断出类型实参，此时不需要显示传入类型实参。（即调用 <code>func Add[T any](a, b T) T</code>时，我们通常可以直接使用<code>sum := Add(a, 2)</code>，而不需要使用<code>sum := Add[int](a, 2)</code>。</li>
</ul>
<p>接下来我们从这几个角度来说明 Go 泛型的设计和使用：</p>
<ul>
<li>类型约束的具体定义</li>
<li>类型推断是如何实现的</li>
<li>一些其他相关知识点</li>
<li>一些类型推断的代码节选</li>
</ul>
<h1 id="类型约束">类型约束</h1>
<p>Go 类型约束可以看作是类型参数的“类型” ，例如下面的例子中，<code>T</code>是类型参数，而<code>Stringer</code>则是类型约束，即<code>T</code>的类型。</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Stringify</span>[<span class="hljs-title">T</span> <span class="hljs-title">Stringer</span>]<span class="hljs-params">(s []T)</span></span> (ret []<span class="hljs-type">string</span>) {
        <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s {
                ret = <span class="hljs-built_in">append</span>(ret, v.String())
        }
        <span class="hljs-keyword">return</span> ret
}

</code></pre>
<p>类型约束自身的类型为 interface，在 Go 1.8 之前，interface 是方法的集合，如上面的例子中，<code>Stringer</code>描述了 T 应该是具有<code>func (T) String() string</code>这个方法的类型。但如果 interface 只能作为方法的集合，下面的函数则无法实现：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span>[<span class="hljs-title">T</span> <span class="hljs-title">constraints</span>.<span class="hljs-title">Integer</span>]<span class="hljs-params">(a, b T)</span></span> T {
        <span class="hljs-keyword">return</span> a + b
}

</code></pre>
<p>试问，<code>constraints.Integer</code>作为一个 interface 如何表述其支持<code>+</code>这个操作呢？实际上 <a href="https://pkg.go.dev/golang.org/x/exp/constraints">constraints</a> 包中的定义如下：</p>
<pre class="hljs"><code><span class="hljs-keyword">type</span> Integer <span class="hljs-keyword">interface</span> {
        Signed | Unsigned
}

<span class="hljs-keyword">type</span> Signed <span class="hljs-keyword">interface</span> {
        ~<span class="hljs-type">int</span> | ~<span class="hljs-type">int8</span> | ~<span class="hljs-type">int16</span> | ~<span class="hljs-type">int32</span> | ~<span class="hljs-type">int64</span>
}

<span class="hljs-keyword">type</span> Unsigned <span class="hljs-keyword">interface</span> {
        ~<span class="hljs-type">uint</span> | ~<span class="hljs-type">uint8</span> | ~<span class="hljs-type">uint16</span> | ~<span class="hljs-type">uint32</span> | ~<span class="hljs-type">uint64</span> | ~<span class="hljs-type">uintptr</span>
}

</code></pre>
<p>可以看到，<code>Integer</code> interface 并没有定义任何方法，这里就涉及到接下来说到的 underlying type。</p>
<h2 id="underlying-type">Underlying type</h2>
<blockquote>
<p>参考：<a href="https://go.dev/ref/spec#Underlying_types">https://go.dev/ref/spec#Underlying_types</a></p>
</blockquote>
<p>范型为了使类型约束的表达更加宽泛，把 interface 的定义从“方法的集合”扩展到了“类型的集合”，两者主要的区别是内置运算符的不同。在 Go 中，<code>&lt;</code>, <code>==</code> 等内置运算符是不支持重置的（Go 本身就没有 override 的概念），只有内置类型可以拥有这些运算符，自定义类型是无法拥有和定义这类运算符的。原先 interface 作为“方法的集合”，无法表达出一个类型是否支持比较相等等内置运算（因为内置运算不能被定义）。为了解决这个问题， Go 引入了 underlying type 并规定凡是 underlying type 支持内置运算符的类型，都能复用其 underlying type 的内置运算。interface 也不仅仅可以用来表达方法集合，而是可以用 ~ underlying type 等语法表示对应的类型集合。</p>
<p>一个类型的 underlying type 的判定规则如下：</p>
<ol>
<li>自身就是underlying type的类型
<ol>
<li>boolean</li>
<li>numeric</li>
<li>string</li>
<li>type literal
<ol>
<li>ArrayType</li>
<li>StructType</li>
<li>PointerType</li>
<li>FunctionType</li>
<li>InterfaceType</li>
<li>SliceType</li>
<li>MapType</li>
<li>ChannelType</li>
</ol>
</li>
</ol>
</li>
<li>不符合以上的情况时，一个类型的underlying type是其被创建时所指向的类型的underlying type。比如：</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">type</span> (
    A1 = <span class="hljs-type">string</span>
    A2 = A1
)

</code></pre>
<p>这里A1符合规则1，其underlying type是string，A2符合规则2，其underlying type是string。</p>
<p>回看上面<code>constraints.Integer</code>的定义，其表达的含义是所有 underlying type 为<code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>uint</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code> 或 <code>uintptr</code>的类型集合。而这些类型都支持<code>+</code>操作，故 <code>Add</code>函数可以被定义出。</p>
<h2 id="使用-type-parameter-和直接使用-interface-的区别">使用 type parameter 和直接使用 interface 的区别</h2>
<blockquote>
<p>参考：<a href="https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#values-of-type-parameters-are-not-boxed">https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#values-of-type-parameters-are-not-boxed</a></p>
</blockquote>
<p>Go 的泛型由于类型约束的存在，看上去会和 interface 类似，在这里与 interface 的主要不同是相关函数的返回值可以是具体的类型，而不只是 interface 。</p>
<p>用上面的 <code>Add</code> 举例子，删除其类型参数则变成：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(a, b <span class="hljs-keyword">interface</span>{})</span></span> <span class="hljs-keyword">interface</span>{} {
        n, _ := a.(<span class="hljs-type">int</span>)
        m, _ := b.(<span class="hljs-type">int</span>)
        <span class="hljs-keyword">return</span> n + m
}

</code></pre>
<p>如果 <code>Add</code>使用上述实现，调用方得到的返回值只能是 <code>interface</code> 或某一个特定的类型，而不能根据调用方的需求返回特定类型。如果返回的是<code>interface</code>，调用方想得到返回值的具体类型，还需要进行拆箱 (unboxing) 操作，如：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
        a, b := <span class="hljs-number">1</span>, <span class="hljs-number">2</span>
        c := Add(a, b)
        d, ok := c.(<span class="hljs-type">int</span>)
        ...
}

</code></pre>
<p>同时，回忆一下 Go 中 interface 实例是如何构造的，一个interface里包含了两个值，代表其指向元素的type和value，构造 interface 实例，即装箱 (boxing) ，这会带来额外的内存开销，泛型可以避免这个内存开销。</p>
<h1 id="类型推断">类型推断</h1>
<p>并不是每次调用支持泛型的函数都需要传入类型参数的，在一些条件下，类型推断可以推断出缺失的类型参数，这个技术被叫做类型推断。注意类型推断并不验证推断出的类型是否能通过编译，该检查在推断结束后进行。</p>
<p>接下来会介绍类型推断的 3 个知识点，并在最后介绍完整的类型推断流程。</p>
<h2 id="类型归一化-type-unification">类型归一化 ( Type unification )</h2>
<blockquote>
<p>参考：<a href="https://go.dev/ref/spec#Type_unification">https://go.dev/ref/spec#Type_unification</a></p>
<p>这个名词我瞎翻译的，ChatGPT 建议翻译这个为“类型统一”</p>
</blockquote>
<h3 id="功能描述">功能描述</h3>
<p><strong>输入</strong></p>
<ol>
<li>映射关系 P -&gt; A，P 代表类型参数，A 代表已知的类型实参。例如 <code>func Add[T any](a, b T) T</code>一个可能的映射关系是 T -&gt; int。</li>
<li>两个类型，这两个类型可以带有类型参数，也可以不带。</li>
</ol>
<p><strong>输出</strong></p>
<ol>
<li>基于已知的映射关系，判断输入的两个类型是否有可能相等。</li>
</ol>
<h3 id="具体操作">具体操作</h3>
<ol>
<li>不带有类型参数的类型，与比较类型必须等价，否则归一失败。
<ol>
<li>两个类型相等自然等价。</li>
<li>如果两个类型是 channel 类型，忽略 channel 方向后类型相等，也可以判定为等价。</li>
<li>如果两个类型的 underlying types 是一致的，那也可以判定为等价。</li>
</ol>
</li>
<li>带有类型参数的类型，在不考虑类型参数的前提下，该类型与比较类型在结构上必须相等，否则归一失败。
<ol>
<li>例如 <code>[]map[T1]T2</code> 和 <code>[]T3</code> 在结构上是一致的，<code>T3</code> 可以被替换成 <code>map[T1]T2</code>，同理 <code>[]map[T1]bool</code> 和 <code>[]map[string]T2</code> 在结构上也是一致的。</li>
<li>例如 <code>[]map[T1]T2</code> 和 <code>int</code>, <code>struct{}</code>, <code>[]struct{}</code> 等类型在结构上不可能一致。</li>
</ol>
</li>
<li>如果匹配成功，且类型带有类型参数，便知道了新的 P’ -&gt; A’ 映射关系，将新的映射关系加入到原有的映射关系中。</li>
</ol>
<h2 id="函数实参类型推断-function-argument-type-inference">函数实参类型推断 ( Function argument type inference )</h2>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#function-argument-type-inference">https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#function-argument-type-inference</a></li>
<li><a href="https://go.dev/ref/spec#Function_argument_type_inference">https://go.dev/ref/spec#Function_argument_type_inference</a></li>
</ul>
</blockquote>
<h3 id="功能描述-2">功能描述</h3>
<ol>
<li>在调用有类型参数的函数时，若调用方没有传入类型参数，则根据实参推断出类型参数。</li>
</ol>
<h3 id="具体实现">具体实现</h3>
<ol>
<li>根据调用方传入实参得到一组 <code>(parameter, argument)</code>，即参数到实参的组合。</li>
<li>先忽略 <code>argument</code> 中没有类型的组合，没有类型即为常量，常量有自身的类型推断规则；对有类型的<code>(parameter, argument)</code>组合，对其对应的类型进行类型归一化，并不断更新映射关系 P -&gt; A。</li>
<li>接下来处理常量的<code>(parameter, argument)</code>组合，如果一个组合中<code>parameter</code>对应的类型参数已经在步骤 3 中被推断出来，那么忽略；如果没有，认定常量<code>argument</code>的取值为该常量对应的默认类型，进行类型归一化。</li>
<li>当所有<code>(parameter, argument)</code>都被处理完成后，推断结束，中途若发生处理失败的情况，则推断失败。</li>
</ol>
<p>接下来用一个示例描述上述步骤：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scale</span>[<span class="hljs-title">Number</span> ~<span class="hljs-title">int64</span>|~<span class="hljs-title">float64</span>|~<span class="hljs-title">complex128</span>]<span class="hljs-params">(v []Number, s Number)</span></span> []Number {
        ...
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">var</span> vector []<span class="hljs-type">float64</span>
        scaledVector := scale(vector, <span class="hljs-number">42</span>)
        ...
}

</code></pre>
<p>函数实参类型推断开始时，得到两个<code>(parameter, argument)</code>组合：</p>
<ol>
<li><code>(v []Number, vector []float64)</code></li>
<li><code>(s Number, 42)</code></li>
</ol>
<p>先对<code>(v []Number, vector []float64)</code>的类型进行类型归一化，得到映射关系<code>Number -&gt; float64</code>。</p>
<p>因为上面已经推断出了映射关系<code>Number -&gt; float64</code>，<code>(s Number, 42)</code>组合就不必进行类型归一化。</p>
<p>如果没有映射关系<code>Number -&gt; float64</code>，<code>(s Number, 42)</code>中 42 的类型会被认定为默认类型 <code>int</code>，那么映射关系则为<code>Number -&gt; int</code>。</p>
<h2 id="约束类型推断-constraint-type-inference">约束类型推断 ( Constraint type inference )</h2>
<blockquote>
<p>参考：<a href="https://go.dev/ref/spec#Constraint_type_inference">https://go.dev/ref/spec#Constraint_type_inference</a></p>
</blockquote>
<h3 id="功能描述-3">功能描述</h3>
<ol>
<li>根据定义的类型参数约束，从一个已知类型参数推导出其他暂时未知的类型参数。</li>
<li>例如有一个函数 <code>func Double[S ~[]E, E constraints.Integer] (s S) S</code> ，这个函数被这样调用 <code>Double([]int{1, 2, 3})</code>，可以从类型约束<code>S ~[]E</code>和<code>S -&gt; []int</code> ，推断出<code>E -&gt; int</code>。</li>
</ol>
<h3 id="具体实现-2">具体实现</h3>
<ol>
<li>遍历所有类型参数
<ol>
<li>如果类型参数已有对应的实参，对两者的 underlying type 进行归一化，如<code>Double</code>的例子中，<code>S</code>的 underlying type 是 <code>[]E</code>，则对<code>[]E</code>和已知实参<code>[]int</code>进行归一化，推断出<code>E -&gt; int</code>。</li>
<li>如果类型参数没有对应的实参，但类型参数的类型约束只有一个类型，那么推断该类型参数对应的实参为约束类型。</li>
</ol>
</li>
<li>在已知的映射关系中，检查是否存在一组 P -&gt; A 和 Q -&gt; B 关系，其中 A 中包含了类型参数 Q，用 B 替换 A 中的 Q。例如<code>func Copy[T any, P *T](value T, dst P)</code>，已知 <code>T -&gt; int</code>，<code>P -&gt; *T</code>，那么可以推断出<code>P -&gt; *int</code>。</li>
<li>重复步骤 2，直到已知的映射关系中再也找不到一个类型参数 P 被某个类型实参 A 包含。</li>
</ol>
<h2 id="类型推断执行步骤">类型推断执行步骤</h2>
<blockquote>
<p>参考：<a href="https://github.com/golang/go/blob/go1.18/src/cmd/compile/internal/types2/infer.go#L33">https://github.com/golang/go/blob/go1.18/src/cmd/compile/internal/types2/infer.go#L33</a></p>
</blockquote>
<p>根据代码注释我们可以知道具体执行步骤如下：</p>
<ol>
<li>利用类型实参进行函数实参类型推断。</li>
<li>再进行一次约束类型推断。</li>
<li>对剩下无类型实参进行函数实参类型推断。</li>
<li>最后进行一次约束类型推断。</li>
</ol>
<p>举一个例子：</p>
<pre class="hljs"><code><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;golang.org/x/exp/constraints&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Multiple</span>[<span class="hljs-title">S</span> ~[]<span class="hljs-title">E</span>, <span class="hljs-title">E</span>, <span class="hljs-title">X</span> <span class="hljs-title">constraints</span>.<span class="hljs-title">Integer</span>]<span class="hljs-params">(s S, x X)</span></span> S {
        <span class="hljs-keyword">for</span> i, e := <span class="hljs-keyword">range</span> s {
                s[i] *= x
        }
        <span class="hljs-keyword">return</span> s
}

<span class="hljs-keyword">type</span> IntVector []<span class="hljs-type">int</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
        vector := IntVector{<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>}
        vector = Multiple(vector, <span class="hljs-number">3</span>)
        fmt.Printf(<span class="hljs-string">&quot;%s\\n&quot;</span>, vector)
        <span class="hljs-comment">// output: [0, 3, 6, 9, 12]</span>
}

</code></pre>
<p><code>Multiple</code>函数类型推断的步骤如下：</p>
<ol>
<li>对有类型的函数实参进行类型推断，即对<code>(s S, vector IntVector)</code>进行类型推断，得到：<code>S -&gt; IntVector</code>。</li>
<li>进行约束类型推断，<code>S</code>的约束为<code>[]E</code>，<code>IntVector</code>的underlying type 为<code>[]int</code>，则对<code>[]E, []int</code>进行类型归一化，得到<code>E -&gt; int</code>。</li>
<li>对无类型函数实参进行类型推断，即对<code>(x X, 3)</code>进行类型推断，对常量 <code>3</code>取默认值 <code>int</code>，得到<code>X -&gt; int</code>。</li>
<li>再次进行约束类型推断，但因为所有参数类型已知，提前结束。</li>
</ol>
<h1 id="其他">其他</h1>
<p>一些其他相关内容整理</p>
<h2 id="泛型窘境">泛型窘境</h2>
<blockquote>
<p>参考：<a href="https://research.swtch.com/generic">https://research.swtch.com/generic</a></p>
</blockquote>
<p>在一个编程语言中添加泛型，势必会增加下列三方中至少一方的复杂度：</p>
<ul>
<li>程序员，C 语言采用了这种方法，即只支持泛型语法，但编译器和运行时都不考虑泛型带来的问题，如有问题程序员自己排查。</li>
<li>编译，C++ 采用了这种方法，在编译时推断出类型，运行时泛型已不存在，这会增加编译耗时以及增加编译产物的数据大小。</li>
<li>运行时，Java 采用了这种方法，在运行时携带参数的类型信息，这会降低运行时的效率，针对 Java，这也引入了类型擦除问题（有兴趣可自行了解）。</li>
</ul>
<p>由前文可以看出，Go 采取的是增加编译耗时，编译时就推断出了一个方法需要的全部类型信息。</p>
<h2 id="使用-t-而不是-t">使用 [T] 而不是 <code>&lt;T&gt;</code></h2>
<p>相信很多同学对泛型的第一印象都是 C++ 或 Java 中的 <code>&lt;T&gt;</code>语法，<a href="https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#why-not-use-the-syntax-like-c_and-java">https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#why-not-use-the-syntax-like-c_and-java</a> 中解释了 <code>&lt;</code>和<code>&gt;</code>两个符号因为也用做比较符号，区分<code>&lt;</code>和<code>&gt;</code>是在表示比较还是类型参数会带来额外的负担，故最后选择了 <code>[T]</code></p>
<h2 id="为何-go-泛型不支持-method">为何 Go 泛型不支持 method？</h2>
<blockquote>
<p>本段说明略跳跃和简短，更详细的说明和示例请参考：<a href="https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#no-parameterized-methods">https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#no-parameterized-methods</a></p>
</blockquote>
<p>在 Go 中，结构体可以使用类型参数，但一个结构体的方法是不被允许使用类型参数的，最主要的原因是因为 Go interface 的特性所致。上文有提到，interface 可以表达“方法的集合”，即一个 interface 可以代表所有实现了其定义方法的结构体。假设说 method 支持泛型，那会出现如下的 interface 定义：</p>
<pre class="hljs"><code><span class="hljs-keyword">type</span> Phone <span class="hljs-keyword">interface</span> {
        Call[N PhoneNumber](n N)
        Download[A App](a A)
}

</code></pre>
<p>同时考虑到 Go 的 interface 和结构体之间没有显式的关系定义，即不存在类似<code>struct iPhone extend Phone</code>这样的语法。因此确定一个 interface 下各个方法的类型参数，以及确定一个类型是否符合一个 interface 会需要大量的类型推断，会给带来非常大的工作量和编译损耗。</p>
<h2 id="支持指针方法">支持指针方法</h2>
<p>当我们定义了一个泛型函数 <code>F[T C]</code>，相应类型参数的约束 <code>C</code>定义了一些方法，向这个函数传入类型 <code>c</code>时，如果<code>C</code>中定义的各种方法被定义在了<code>*c</code>类型而不是 <code>c</code>上，此时代码将无法编译。</p>
<p>举一个具体例子：</p>
<pre class="hljs"><code><span class="hljs-keyword">type</span> Setter <span class="hljs-keyword">interface</span> {
        Set(<span class="hljs-type">string</span>)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FromStrings</span>[<span class="hljs-title">T</span> <span class="hljs-title">Setter</span>]<span class="hljs-params">(s []<span class="hljs-type">string</span>)</span></span> []T {
        result := <span class="hljs-built_in">make</span>([]T, <span class="hljs-built_in">len</span>(s))
        <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> s {
                result[i].Set(v)
        }
        <span class="hljs-keyword">return</span> result
}

<span class="hljs-keyword">type</span> Settable <span class="hljs-type">int</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Settable)</span></span> Set(s <span class="hljs-type">string</span>) {
        i, _ := strconv.Atoi(s) <span class="hljs-comment">// real code should not ignore the error</span>
        *p = Settable(i)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">F</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// INVALID</span>
        nums := FromStrings[Settable]([]<span class="hljs-type">string</span>{<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>})
        <span class="hljs-comment">// Here we want nums to be []Settable{1, 2}.</span>
        ...
}

</code></pre>
<p>上面的例子中，<code>result</code>的类型为<code>[]Settable</code>，而<code>Settable</code>并不支持 <code>Set</code> 方法，支持<code>Set</code>方法的是<code>*Settable</code>，故<code>result[i].Set(v)</code>无法正常调用。</p>
<p>相应的解法如下：</p>
<pre class="hljs"><code><span class="hljs-keyword">type</span> Setter2[B any] <span class="hljs-keyword">interface</span> {
        Set(<span class="hljs-type">string</span>)
        *B <span class="hljs-comment">// non-interface type constraint element</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FromStrings2</span>[<span class="hljs-title">T</span> <span class="hljs-title">any</span>, <span class="hljs-title">PT</span> <span class="hljs-title">Setter2</span>[<span class="hljs-title">T</span>]]<span class="hljs-params">(s []<span class="hljs-type">string</span>)</span></span> []T {
        result := <span class="hljs-built_in">make</span>([]T, <span class="hljs-built_in">len</span>(s))
        <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> s {
                <span class="hljs-comment">// The type of &amp;result[i] is *T which is in the type set</span>
                <span class="hljs-comment">// of Setter2, so we can convert it to PT.</span>
                p := PT(&amp;result[i])
                <span class="hljs-comment">// PT has a Set method.</span>
                p.Set(v)
        }
        <span class="hljs-keyword">return</span> result
}

</code></pre>
<p>即在泛型函数中明确区分出类型<code>T</code>和其对应的指针类型 <code>PT</code>，并通过类型约束<code>Setter2[B any]</code>定义其之间的转化关系，调用<code>Set</code>时转换类型，调用成功。</p>
<h2 id="在工作中使用泛型">在工作中使用泛型</h2>
<p>以上，我们从 Go 的类型约束出发，了解了定义泛型函数需要的知识点，并了解了类型推断的关键点，最后我们讨论下在泛型在工作中的应用：</p>
<ul>
<li>容器操作。</li>
<li>通用数据结构。</li>
<li>通用操作逻辑，自己日常维护的代码中有请求数据网关服务的操作，由于数据网关返回的数据是一个固定的结构体，使用相对比较麻烦，自己用泛型对请求和返回进行了封装，使不同数据源返回的数据可以转化为特定的结构体。</li>
</ul>
<p>如果你在工作中有其他的泛型使用方法，或者有其他好用的泛型库推荐，欢迎评论补充 : )</p>
<h1 id="类型推断代码">类型推断代码</h1>
<h2 id="类型归一化">类型归一化</h2>
<blockquote>
<p>参考：<a href="https://github.com/golang/go/blob/go1.18/src/cmd/compile/internal/types2/unify.go">https://github.com/golang/go/blob/go1.18/src/cmd/compile/internal/types2/unify.go</a></p>
</blockquote>
<p>不断递归判断<code>x, y Type</code>在映射关系<code>p * ifacePair</code>下是否有可能相等，如果发现<code>x</code>或<code>y</code>为没有推断出的类型参数，则匹配并返回相等。</p>
<pre class="hljs"><code><span class="hljs-comment">// nify implements the core unification algorithm which is an</span>
<span class="hljs-comment">// adapted version of Checker.identical. For changes to that</span>
<span class="hljs-comment">// code the corresponding changes should be made here.</span>
<span class="hljs-comment">// Must not be called directly from outside the unifier.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *unifier)</span></span> nify(x, y Type, p *ifacePair) (result <span class="hljs-type">bool</span>) {

        ......

        <span class="hljs-comment">// Cases where at least one of x or y is a type parameter.</span>
        <span class="hljs-keyword">switch</span> i, j := u.x.index(x), u.y.index(y); {
        <span class="hljs-keyword">case</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>:
                <span class="hljs-comment">// both x and y are type parameters</span>
                <span class="hljs-keyword">if</span> u.join(i, j) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
                }
                <span class="hljs-comment">// both x and y have an inferred type - they must match</span>
                <span class="hljs-keyword">return</span> u.nifyEq(u.x.at(i), u.y.at(j), p)

        <span class="hljs-keyword">case</span> i &gt;= <span class="hljs-number">0</span>:
                <span class="hljs-comment">// x is a type parameter, y is not</span>
                <span class="hljs-keyword">if</span> tx := u.x.at(i); tx != <span class="hljs-literal">nil</span> {
                        <span class="hljs-keyword">return</span> u.nifyEq(tx, y, p)
                }
                <span class="hljs-comment">// otherwise, infer type from y</span>
                u.x.set(i, y)
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>

        <span class="hljs-keyword">case</span> j &gt;= <span class="hljs-number">0</span>:

                ......

        }

        ......

        <span class="hljs-keyword">switch</span> x := x.(<span class="hljs-keyword">type</span>) {

        ......

        <span class="hljs-keyword">case</span> *Slice:
                <span class="hljs-comment">// Two slice types are identical if they have identical element types.</span>
                <span class="hljs-keyword">if</span> y, ok := y.(*Slice); ok {
                        <span class="hljs-keyword">return</span> u.nify(x.elem, y.elem, p)
                }

        <span class="hljs-keyword">case</span> *Struct:
                <span class="hljs-comment">// Two struct types are identical if they have the same sequence of fields,</span>
                <span class="hljs-comment">// and if corresponding fields have the same names, and identical types,</span>
                <span class="hljs-comment">// and identical tags. Two embedded fields are considered to have the same</span>
                <span class="hljs-comment">// name. Lower-case field names from different packages are always different.</span>
                <span class="hljs-keyword">if</span> y, ok := y.(*Struct); ok {
                        <span class="hljs-keyword">if</span> x.NumFields() == y.NumFields() {
                                <span class="hljs-keyword">for</span> i, f := <span class="hljs-keyword">range</span> x.fields {
                                        g := y.fields[i]
                                        <span class="hljs-keyword">if</span> f.embedded != g.embedded ||
                                                x.Tag(i) != y.Tag(i) ||
                                                !f.sameId(g.pkg, g.name) ||
                                                !u.nify(f.typ, g.typ, p) {
                                                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
                                        }
                                }
                                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
                        }
                }

        ......

        <span class="hljs-keyword">default</span>:
                <span class="hljs-built_in">panic</span>(sprintf(<span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;u.nify(%s, %s), u.x.tparams = %s&quot;</span>, x, y, u.x.tparams))
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
}

</code></pre>
<h2 id="函数实参类型推断">函数实参类型推断</h2>
<h3 id="有类型的实参直接归一化">有类型的实参直接归一化</h3>
<blockquote>
<p>参考：<a href="https://github.com/golang/go/blob/go1.18/src/cmd/compile/internal/types2/infer.go#L250">https://github.com/golang/go/blob/go1.18/src/cmd/compile/internal/types2/infer.go#L250</a></p>
</blockquote>
<pre class="hljs"><code>        <span class="hljs-comment">// indices of the generic parameters with untyped arguments - save for later</span>
        <span class="hljs-keyword">var</span> indices []<span class="hljs-type">int</span>
        <span class="hljs-keyword">for</span> i, arg := <span class="hljs-keyword">range</span> args {
                par := params.At(i)
                <span class="hljs-comment">// If we permit bidirectional unification, this conditional code needs to be</span>
                <span class="hljs-comment">// executed even if par.typ is not parameterized since the argument may be a</span>
                <span class="hljs-comment">// generic function (for which we want to infer its type arguments).</span>
                <span class="hljs-keyword">if</span> isParameterized(tparams, par.typ) {
                        <span class="hljs-keyword">if</span> arg.mode == invalid {
                                <span class="hljs-comment">// An error was reported earlier. Ignore this targ</span>
                                <span class="hljs-comment">// and continue, we may still be able to infer all</span>
                                <span class="hljs-comment">// targs resulting in fewer follow-on errors.</span>
                                <span class="hljs-keyword">continue</span>
                        }
                        <span class="hljs-keyword">if</span> targ := arg.typ; isTyped(targ) {
                                <span class="hljs-comment">// If we permit bidirectional unification, and targ is</span>
                                <span class="hljs-comment">// a generic function, we need to initialize u.y with</span>
                                <span class="hljs-comment">// the respective type parameters of targ.</span>
                                <span class="hljs-keyword">if</span> !u.unify(par.typ, targ) {
                                        errorf(<span class="hljs-string">&quot;type&quot;</span>, par.typ, targ, arg)
                                        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
                                }
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> _, ok := par.typ.(*TypeParam); ok {
                                <span class="hljs-comment">// Since default types are all basic (i.e., non-composite) types, an</span>
                                <span class="hljs-comment">// untyped argument will never match a composite parameter type; the</span>
                                <span class="hljs-comment">// only parameter type it can possibly match against is a *TypeParam.</span>
                                <span class="hljs-comment">// Thus, for untyped arguments we only need to look at parameter types</span>
                                <span class="hljs-comment">// that are single type parameters.</span>
                                indices = <span class="hljs-built_in">append</span>(indices, i)
                        }
                }
        }

</code></pre>
<h3 id="没有类型的实参赋予常量默认值后归一化">没有类型的实参赋予常量默认值后归一化</h3>
<blockquote>
<p>参考：<a href="https://github.com/golang/go/blob/go1.18/src/cmd/compile/internal/types2/infer.go#L297">https://github.com/golang/go/blob/go1.18/src/cmd/compile/internal/types2/infer.go#L297</a></p>
</blockquote>
<pre class="hljs"><code>        <span class="hljs-comment">// Use any untyped arguments to infer additional type arguments.</span>
        <span class="hljs-comment">// Some generic parameters with untyped arguments may have been given</span>
        <span class="hljs-comment">// a type by now, we can ignore them.</span>
        <span class="hljs-keyword">for</span> _, i := <span class="hljs-keyword">range</span> indices {
                tpar := params.At(i).typ.(*TypeParam) <span class="hljs-comment">// is type parameter by construction of indices</span>
                <span class="hljs-comment">// Only consider untyped arguments for which the corresponding type</span>
                <span class="hljs-comment">// parameter doesn&#x27;t have an inferred type yet.</span>
                <span class="hljs-keyword">if</span> targs[tpar.index] == <span class="hljs-literal">nil</span> {
                        arg := args[i]
                        targ := Default(arg.typ)
                        <span class="hljs-comment">// The default type for an untyped nil is untyped nil. We must not</span>
                        <span class="hljs-comment">// infer an untyped nil type as type parameter type. Ignore untyped</span>
                        <span class="hljs-comment">// nil by making sure all default argument types are typed.</span>
                        <span class="hljs-keyword">if</span> isTyped(targ) &amp;&amp; !u.unify(tpar, targ) {
                                errorf(<span class="hljs-string">&quot;default type&quot;</span>, tpar, targ, arg)
                                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
                        }
                }
        }

</code></pre>
<h2 id="约束类型推断">约束类型推断</h2>
<blockquote>
<p>参考：<a href="https://github.com/golang/go/blob/go1.18/src/cmd/compile/internal/types2/infer.go#L468">https://github.com/golang/go/blob/go1.18/src/cmd/compile/internal/types2/infer.go#L468</a></p>
</blockquote>
<h3 id="类型参数-core-type-处理">类型参数 core type 处理</h3>
<p>在约束类型推断的一阶段，引入了一个新概念 core type，本文不做过多介绍，可以理解为类型约束对应约束类型的 underlying type。利用 core type 与已知实参可以完成一些类型推断。</p>
<pre class="hljs"><code>                <span class="hljs-keyword">for</span> i, tpar := <span class="hljs-keyword">range</span> tparams {
                        <span class="hljs-comment">// If there is a core term (i.e., a core type with tilde information)</span>
                        <span class="hljs-comment">// unify the type parameter with the core type.</span>
                        <span class="hljs-keyword">if</span> core, single := coreTerm(tpar); core != <span class="hljs-literal">nil</span> {
                                <span class="hljs-comment">// A type parameter can be unified with its core type in two cases.</span>
                                tx := u.x.at(i)
                                <span class="hljs-keyword">switch</span> {
                                <span class="hljs-keyword">case</span> tx != <span class="hljs-literal">nil</span>:

                                        ......

                                        <span class="hljs-keyword">if</span> !u.unify(tx, core.typ) {
                                                <span class="hljs-comment">// TODO(gri) improve error message by providing the type arguments</span>
                                                <span class="hljs-comment">//           which we know already</span>
                                                <span class="hljs-comment">// Don&#x27;t use term.String() as it always qualifies types, even if they</span>
                                                <span class="hljs-comment">// are in the current package.</span>
                                                tilde := <span class="hljs-string">&quot;&quot;</span>
                                                <span class="hljs-keyword">if</span> core.tilde {
                                                        tilde = <span class="hljs-string">&quot;~&quot;</span>
                                                }
                                                check.errorf(pos, <span class="hljs-string">&quot;%s does not match %s%s&quot;</span>, tpar, tilde, core.typ)
                                                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-number">0</span>
                                        }

                                <span class="hljs-keyword">case</span> single &amp;&amp; !core.tilde:
                                        <span class="hljs-comment">// The corresponding type argument tx is unknown and there&#x27;s a single</span>
                                        <span class="hljs-comment">// specific type and no tilde.</span>
                                        <span class="hljs-comment">// In this case the type argument must be that single type; set it.</span>
                                        u.x.set(i, core.typ)

                                <span class="hljs-keyword">default</span>:
                                        <span class="hljs-comment">// Unification is not possible and no progress was made.</span>
                                        <span class="hljs-keyword">continue</span>
                                }

                                ......

                        }
                }

</code></pre>
<h3 id="映射关系化简">映射关系化简</h3>
<p>约束类型推断的二阶段，不断化简映射关系。</p>
<pre class="hljs"><code>                smap := makeSubstMap(tparams, types)
                n := <span class="hljs-number">0</span>
                <span class="hljs-keyword">for</span> _, index := <span class="hljs-keyword">range</span> dirty {
                        t0 := types[index]
                        <span class="hljs-keyword">if</span> t1 := check.subst(nopos, t0, smap, <span class="hljs-literal">nil</span>); t1 != t0 {
                                types[index] = t1
                                dirty[n] = index
                                n++
                        }
                }

</code></pre>
</div>
</div>

            <section class="citation-section" data-citation-section></section>
            <section class="comment-section" data-comment-section></section>
          </div>
        </div>
      </main>
    </div>

    <script id="page-data" type="application/json">
      {
  "pageType": "post",
  "lang": "zh",
  "langSwitchUrl": "/golang-generics/",
  "langSwitcherMode": "toggle",
  "markdownUrl": "/posts/golang-generics/post.md",
  "labels": {
    "navAbout": "About",
    "navBlog": "Blog",
    "filterAll": "All"
  },
  "comments": {
    "appId": "e224d3ce-6f5a-4777-bb80-b7bbf2e78d83",
    "pageId": "golang-generics",
    "pageUrl": "https://www.yujiachen.com/golang-generics/zh/",
    "pageTitle": "Golang 泛型"
  }
}
    </script>
    <script type="module" src="/app.js"></script>
  </body>
</html>
