<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- iOS Safari -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- Chrome, Firefox OS and Opera Status Bar Color -->
<meta name="theme-color" content="#FFFFFF">
<link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css" />
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
<link rel="stylesheet" type="text/css"
  href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.19.0/themes/prism.min.css">
<link rel="stylesheet" type="text/css" href="css/SourceSansPro.css">
<link rel="stylesheet" type="text/css" href="css/theme.css">
<link rel="stylesheet" type="text/css" href="css/notablog.css">
<!-- Favicon -->

  <link rel="shortcut icon" href="https://raw.githubusercontent.com/yujiachen-y/yjc567.github.io/main/pictures/icon.JPG">

<style>
  :root {
    font-size: 20px;
  }
</style>
  <title>Golang 泛型&nbsp;|&nbsp;Jiachen’s Blog</title>
  <meta property="og:type" content="blog">
  <meta property="og:title" content="Golang 泛型">
  
  
  <style>
    .DateTagBar {
      margin-top: 1.0rem;
    }
  </style>
</head>

<body>
  <nav class="Navbar">
  <a href="index.html">
    <div class="Navbar__Btn">
      
        <span><img class="inline-img-icon" src="https://raw.githubusercontent.com/yujiachen-y/yjc567.github.io/main/pictures/icon.JPG"></span>&nbsp;
      
      <span>主页</span>
    </div>
  </a>
  <span class="Navbar__Delim">&centerdot;</span>
  <a href="tag/%E6%9D%82%E6%96%87.html">
    <div class="Navbar__Btn">
      <span>杂文</span>
    </div>
  </a>
  <span class="Navbar__Delim">&centerdot;</span>
  <a href="tag/%E6%8A%80%E6%9C%AF.html">
    <div class="Navbar__Btn">
      <span>技术</span>
    </div>
  </a>
  <span class="Navbar__Delim">&centerdot;</span>
  <a href="tag/%E9%98%85%E8%AF%BB.html">
    <div class="Navbar__Btn">
      <span>阅读</span>
    </div>
  </a>
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="other.html">
        <div class="Navbar__Btn">
          
          <span>其他</span>
        </div>
      </a>
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="about.html">
        <div class="Navbar__Btn">
          
          <span>关于</span>
        </div>
      </a>
    
  
</nav>
  <header class="Header">
    
    <div class="Header__Spacer Header__Spacer--NoCover">
    </div>
    
    <h1 class="Header__Title">Golang 泛型</h1>
    
      <div class="DateTagBar">
        
          <span class="DateTagBar__Item DateTagBar__Date">Posted on 2023年5月26日周五</span>
        
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--gray">
            <a href="tag/技术.html">技术</a>
          </span>
        
      </div>
    
  </header>
  <article id="https://www.notion.so/e3aa8f6ff06a42e0b2d0c3097d1fc875" class="PageRoot"><ul id="https://www.notion.so/5ea770e279bc43b1a38a6089869cf94f" class="ColorfulBlock ColorfulBlock--ColorGray TableOfContents"><li class="TableOfContents__Item"><a href="#https://www.notion.so/12b32681f63346508984c57d233184d0"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">名词解释</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/1ad71c6916544a7dbb3545dad0717625"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">总览</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/66c4f4f7059143b6ae722289631c3a35"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">类型约束</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/8f2a5146812d4518bd5ad0beb1a371a0"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">Underlying type</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/75bd1b15944345808c38bcab5ba5f422"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">使用 type parameter 和直接使用 interface 的区别</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/f5372442b01d4055a347ceb15ccaa0c3"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">类型推断</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/1e6ce83d79ba4356b2fc1aa62f49b562"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">类型归一化 ( Type unification )</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/6e58cc214e8b4df68b0ae7f73a6e76c0"><div style="margin-left:48px"><span class="SemanticStringArray"><span class="SemanticString">功能描述</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/c458186488914c0795d7d6d3bdfc5dca"><div style="margin-left:48px"><span class="SemanticStringArray"><span class="SemanticString">具体操作</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/8a3b5498a94546799d93d2ac47e62c0d"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">函数实参类型推断 ( Function argument type inference )</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/58380d8f707349a9bb723c982b0f8018"><div style="margin-left:48px"><span class="SemanticStringArray"><span class="SemanticString">功能描述</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/8b35820984024950a32693ed61171114"><div style="margin-left:48px"><span class="SemanticStringArray"><span class="SemanticString">具体实现</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/d2f2b1008f9d4af08960a69efa887ee2"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">约束类型推断 ( Constraint type inference )</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/9d73782a06d64f54bb80f9f8e2266ea5"><div style="margin-left:48px"><span class="SemanticStringArray"><span class="SemanticString">功能描述</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/b08cfb17587e4f5e83712adc88600d0e"><div style="margin-left:48px"><span class="SemanticStringArray"><span class="SemanticString">具体实现</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/6f3daefb14bc4e59b06987554892177e"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">类型推断执行步骤</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/0fee66bdfcd34ef88358650f74599c60"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">其他</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/10606d83443b4478bec92dc6b85ddf3a"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">泛型窘境</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/2dc6e69262dd4149b2ce1c026cdf8ed8"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">使用 [T] 而不是 &lt;T&gt;</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/9b27a71f154446e0ae56c5101e2f17d4"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">为何 Go 泛型不支持 method？</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/adc0663a13124a89b748de4cbafdee7e"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">支持指针方法</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/8be1cdcb85b24e16b7e344733c5c818d"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">在工作中使用泛型</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/b1cc464f72e849ac86d8a2a9deceef22"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">类型推断代码</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/445e764cc9574855b17a4b5e69faabfc"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">类型归一化</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/5106e64fcc6d411598613b707bc91b2f"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">函数实参类型推断</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/3c39dd4765cd4c09afeb45b9f14fdd84"><div style="margin-left:48px"><span class="SemanticStringArray"><span class="SemanticString">有类型的实参直接归一化</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/28847dbd2a114004844fb10507f7007e"><div style="margin-left:48px"><span class="SemanticStringArray"><span class="SemanticString">没有类型的实参赋予常量默认值后归一化</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/8fc2874de25645778c0d727ce68db288"><div style="margin-left:24px"><span class="SemanticStringArray"><span class="SemanticString">约束类型推断</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/a729c85939ab4a3a8cfa5d695cff3ac9"><div style="margin-left:48px"><span class="SemanticStringArray"><span class="SemanticString">类型参数 core type 处理</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/b00bef1d33e0426b941899c9b3383084"><div style="margin-left:48px"><span class="SemanticStringArray"><span class="SemanticString">映射关系化简</span></span></div></a></li></ul><div id="https://www.notion.so/9058da87e0854ec88d9061594719290b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">泛型是一种编程范式，允许在编写代码时使用通用的类型，从而提高代码的复用性和灵活性。在许多编程语言（如 Java、C++ 和 C#）中，泛型已经成为一种非常重要的特性，使得开发者能够编写更加通用、灵活且类型安全的代码。然而，Go 语言在最初的设计中并没有包含泛型特性，这导致了一些局限性和不便。随着 Go 语言的发展，为了使其更加完善，并满足开发者在实际工作中的需求，Go 语言社区逐渐引入了泛型特性。通过引入泛型，Go 语言能够实现更加通用的数据结构和函数，从而提高开发效率和代码质量。</span></span></p></div><div id="https://www.notion.so/c4575fd27e8c4b29b9443de1644e1ce5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">举个例子：</span></span></p></div><pre id="https://www.notion.so/9478113c6f954d7ca7422a34e9be7269" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>import &quot;golang.org/x/exp/constraints&quot;

func GMin[T constraints.Ordered](x, y T) T {
    if x &lt; y {
        return x
    }
    return y
}
</span></span></span></code></pre><div id="https://www.notion.so/d61b7c7900e9419ba5b87ee9918c448d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">不过 Go 泛型和其他语言的泛型略有不同，本文从 Go 的类型参数提案出发，结合实现代码和示例，说明 Go 泛型的一些特性，期望可以达到让大家在工作中更好更高效使用泛型的目的。</span></span></p></div><blockquote id="https://www.notion.so/e00415fa2a80482fa54e2821f614979c" class="ColorfulBlock ColorfulBlock--BgGray Quote"><span class="SemanticStringArray"><span class="SemanticString">主要参考：https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md</span></span></blockquote><h1 id="https://www.notion.so/12b32681f63346508984c57d233184d0" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/12b32681f63346508984c57d233184d0"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">名词解释</span></span></h1><ul class="BulletedListWrapper"><li id="https://www.notion.so/08be4fadcf2c4946ae2d62eaf4215c9e" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">parameter，也被称作形参，指函数定义时指定需要传入的参数，实际上是一个占位符，没有真实值，例如 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">func Add(a, b int) int</code></span><span class="SemanticString"> 中的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">a</code></span><span class="SemanticString"> 和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">b</code></span><span class="SemanticString"> 。下文用类型参数指代，例如 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">func Add[T any](a, b T) T</code></span><span class="SemanticString"> 中的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">T</code></span><span class="SemanticString"> 就是 type parameter 类型参数。</span></span></li><li id="https://www.notion.so/da8f2012652e401ab20e2759bfc022b5" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">argument，也被称作实参，指函数被调用时实际传入的参数，是一个真实值，例如 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">sum := Add[int](a, 2)</code></span><span class="SemanticString"> 中的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">a</code></span><span class="SemanticString"> 和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">2</code></span><span class="SemanticString">，此示例中 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">a</code></span><span class="SemanticString"> 是一个命名变量或常量，2 是一个未命名常量。下文用类型实参，例子中 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Add[int]</code></span><span class="SemanticString"> 中的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">int</code></span><span class="SemanticString"> 就是 type argument 类型实参。</span></span></li><li id="https://www.notion.so/0ee9fbfaf23d4e54b4cc82ea2a6d4e7a" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">function，指 Golang 中的函数，如 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">func Add(a, b int) int</code></span><span class="SemanticString">。https://go.dev/ref/spec#Function_types</span></span></li><li id="https://www.notion.so/fe2c73a3c5e54586b89c351476affee6" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">method，指 Golang 中结构体的方法，如 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">func (s *Struct) Get() string</code></span><span class="SemanticString">。https://go.dev/ref/spec#Method_declarations</span></span></li><li id="https://www.notion.so/a40b004b6a74407996b327f552caed80" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">operation，可以理解为 Golang 中内置类型支持的运算符（见下），Go spec 中使用 operator 这个名词。https://go.dev/ref/spec#Operators</span></span></li></ul><pre id="https://www.notion.so/1f6627303c6f4e01a2595d1d13c3ad2e" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>Expression = UnaryExpr | Expression binary_op Expression .
UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

binary_op  = &quot;||&quot; | &quot;&amp;&amp;&quot; | rel_op | add_op | mul_op .
rel_op     = &quot;==&quot; | &quot;!=&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;&gt;&quot; | &quot;&gt;=&quot; .
add_op     = &quot;+&quot; | &quot;-&quot; | &quot;|&quot; | &quot;^&quot; .
mul_op     = &quot;*&quot; | &quot;/&quot; | &quot;%&quot; | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; | &quot;&amp;&quot; | &quot;&amp;^&quot; .

unary_op   = &quot;+&quot; | &quot;-&quot; | &quot;!&quot; | &quot;^&quot; | &quot;*&quot; | &quot;&amp;&quot; | &quot;&lt;-&quot; .
</span></span></span></code></pre><h1 id="https://www.notion.so/1ad71c6916544a7dbb3545dad0717625" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/1ad71c6916544a7dbb3545dad0717625"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">总览</span></span></h1><div id="https://www.notion.so/8999214a59c74db6a6e23b75ba5d2e22" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Go 类型参数提案归纳了 Go 类型参数的几个要点（https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#summary）：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/45260c4326184c5889827142f8137004" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">函数和类型可以有类型参数，类型参数由类型约束定义，类型约束的类型为 interface。(注意，这里没有提及方法，也就是说方法不可以有类型参数）</span></span></li><li id="https://www.notion.so/cf5fd5a3b54d474d866237e64b8f8fdf" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">类型约束描述了 type argument，即传入的实参需要实现的方法，和允许传入实参的类型。</span></span></li><li id="https://www.notion.so/9b7f2a4958c4487e8b0f35af7facc5c5" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">类型约束描述了 type parameter，即定义的形参支持的方法和运算符。</span></span></li><li id="https://www.notion.so/5e8f7c30018e4e7e8ce95639367f4af2" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">当调用支持类型参数的函数时，类型推断有时可以推断出类型实参，此时不需要显示传入类型实参。（即调用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">func Add[T any](a, b T) T</code></span><span class="SemanticString">时，我们通常可以直接使用</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">sum := Add(a, 2)</code></span><span class="SemanticString">，而不需要使用</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">sum := Add[int](a, 2)</code></span><span class="SemanticString">。</span></span></li></ul><div id="https://www.notion.so/838822f38a50413b88bd368f615fb7ba" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">接下来我们从这几个角度来说明 Go 泛型的设计和使用：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/e6859dc682ad4212833b7d41cb2665e6" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">类型约束的具体定义</span></span></li><li id="https://www.notion.so/6157bb55ba224b0b8c5844fabdaa72c5" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">类型推断是如何实现的</span></span></li><li id="https://www.notion.so/79495c4ad17c468198a3f4fffef4b750" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">一些其他相关知识点</span></span></li><li id="https://www.notion.so/fc09d3aebb7a4503862941b9533a7855" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">一些类型推断的代码节选</span></span></li></ul><h1 id="https://www.notion.so/66c4f4f7059143b6ae722289631c3a35" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/66c4f4f7059143b6ae722289631c3a35"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">类型约束</span></span></h1><div id="https://www.notion.so/e573a655c6834af6af777b4a0bd504b2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Go 类型约束可以看作是类型参数的“类型” ，例如下面的例子中，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">T</code></span><span class="SemanticString">是类型参数，而</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Stringer</code></span><span class="SemanticString">则是类型约束，即</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">T</code></span><span class="SemanticString">的类型。</span></span></p></div><pre id="https://www.notion.so/1b1dd446e3ba47acb2681622c4a519d9" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>func Stringify[T Stringer](s []T) (ret []string) {
        for _, v := range s {
                ret = append(ret, v.String())
        }
        return ret
}
</span></span></span></code></pre><div id="https://www.notion.so/d28167ff4c9a4fbd810a64f191398497" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">类型约束自身的类型为 interface，在 Go 1.8 之前，interface 是方法的集合，如上面的例子中，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Stringer</code></span><span class="SemanticString">描述了 T 应该是具有</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">func (T) String() string</code></span><span class="SemanticString">这个方法的类型。但如果 interface 只能作为方法的集合，下面的函数则无法实现：</span></span></p></div><pre id="https://www.notion.so/604c435e4e8441c1b410530df3942fb9" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>func Add[T constraints.Integer](a, b T) T {
        return a + b
}
</span></span></span></code></pre><div id="https://www.notion.so/57da184d70704cdaa62f064f105f353b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">试问，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">constraints.Integer</code></span><span class="SemanticString">作为一个 interface 如何表述其支持</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">+</code></span><span class="SemanticString">这个操作呢？实际上 </span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://pkg.go.dev/golang.org/x/exp/constraints">constraints</a></span><span class="SemanticString"> 包中的定义如下：</span></span></p></div><pre id="https://www.notion.so/b5636886a11b4ec3968a23033ac6b830" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>type Integer interface {
        Signed | Unsigned
}

type Signed interface {
        ~int | ~int8 | ~int16 | ~int32 | ~int64
}

type Unsigned interface {
        ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr
}
</span></span></span></code></pre><div id="https://www.notion.so/f6f20d84e1dd467d915d8c4493cd981e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">可以看到，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Integer</code></span><span class="SemanticString"> interface 并没有定义任何方法，这里就涉及到接下来说到的 underlying type。</span></span></p></div><h2 id="https://www.notion.so/8f2a5146812d4518bd5ad0beb1a371a0" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/8f2a5146812d4518bd5ad0beb1a371a0"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Underlying type</span></span></h2><blockquote id="https://www.notion.so/5a77e6305ce74b82a8abae691273cc77" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">参考：https://go.dev/ref/spec#Underlying_types</span></span></blockquote><div id="https://www.notion.so/6ec823516bfb4e53b27f26f67595a06b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">范型为了使类型约束的表达更加宽泛，把 interface 的定义从“方法的集合”扩展到了“类型的集合”，两者主要的区别是内置运算符的不同。在 Go 中，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">&lt;</code></span><span class="SemanticString">, </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">==</code></span><span class="SemanticString"> 等内置运算符是不支持重置的（Go 本身就没有 override 的概念），只有内置类型可以拥有这些运算符，自定义类型是无法拥有和定义这类运算符的。原先 interface 作为“方法的集合”，无法表达出一个类型是否支持比较相等等内置运算（因为内置运算不能被定义）。为了解决这个问题， Go 引入了 underlying type 并规定凡是 underlying type 支持内置运算符的类型，都能复用其 underlying type 的内置运算。interface 也不仅仅可以用来表达方法集合，而是可以用 ~ underlying type 等语法表示对应的类型集合。</span></span></p></div><div id="https://www.notion.so/f1ef308a62e04d5aaed188e48c9b3275" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">一个类型的 underlying type 的判定规则如下：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/59b603f7af844ccdb1d22b4341888309" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">自身就是underlying type的类型</span></span><ol class="NumberedListWrapper"><li id="https://www.notion.so/a829559213d649b3a376802660ff4612" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">boolean</span></span></li><li id="https://www.notion.so/b02259c4a39148c1a4278b72ef4685e1" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">numeric</span></span></li><li id="https://www.notion.so/f5da6f48a223421da739c47010310179" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">string</span></span></li><li id="https://www.notion.so/8fdd53490e7f475795dfea5daa509f5b" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">type literal</span></span><ol class="NumberedListWrapper"><li id="https://www.notion.so/f2769f44d5994770872e9759474872f8" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">ArrayType</span></span></li><li id="https://www.notion.so/8568b177e2a24899b808e9ec8711e97c" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">StructType</span></span></li><li id="https://www.notion.so/62a2a2d5a9544837a1c636e2c151cc94" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">PointerType</span></span></li><li id="https://www.notion.so/1b694b23cd1047b4a05828aa1070712a" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">FunctionType</span></span></li><li id="https://www.notion.so/6d0b641b353243549313010930d60b8f" class="NumberedList" value="5"><span class="SemanticStringArray"><span class="SemanticString">InterfaceType</span></span></li><li id="https://www.notion.so/93da3e7da1804529bd9014438e80cfc1" class="NumberedList" value="6"><span class="SemanticStringArray"><span class="SemanticString">SliceType</span></span></li><li id="https://www.notion.so/ffe6647b4de9447d9ed4dd37ea94b52b" class="NumberedList" value="7"><span class="SemanticStringArray"><span class="SemanticString">MapType</span></span></li><li id="https://www.notion.so/4493547a3989409fa6ae958520bd7c2a" class="NumberedList" value="8"><span class="SemanticStringArray"><span class="SemanticString">ChannelType</span></span></li></ol></li></ol></li><li id="https://www.notion.so/b2e47158babc40de89ebf6891998e0af" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">不符合以上的情况时，一个类型的underlying type是其被创建时所指向的类型的underlying type。比如：</span></span></li></ol><pre id="https://www.notion.so/f4aa55415f844f0db2e52d0103b3522d" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>type (
    A1 = string
    A2 = A1
)
</span></span></span></code></pre><div id="https://www.notion.so/fed0e73cf59e4a9cb3e84f7cbe452448" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">这里A1符合规则1，其underlying type是string，A2符合规则2，其underlying type是string。</span></span></p></div><div id="https://www.notion.so/301e00b7a46749bfb2dddadf4f4bc0e8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">回看上面</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">constraints.Integer</code></span><span class="SemanticString">的定义，其表达的含义是所有 underlying type 为</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">int</code></span><span class="SemanticString">, </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">int8</code></span><span class="SemanticString">, </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">int16</code></span><span class="SemanticString">, </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">int32</code></span><span class="SemanticString">, </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">int64</code></span><span class="SemanticString">, </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">uint</code></span><span class="SemanticString">, </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">uint8</code></span><span class="SemanticString">, </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">uint16</code></span><span class="SemanticString">, </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">uint32</code></span><span class="SemanticString">, </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">uint64</code></span><span class="SemanticString"> 或 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">uintptr</code></span><span class="SemanticString">的类型集合。而这些类型都支持</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">+</code></span><span class="SemanticString">操作，故 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Add</code></span><span class="SemanticString">函数可以被定义出。</span></span></p></div><h2 id="https://www.notion.so/75bd1b15944345808c38bcab5ba5f422" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/75bd1b15944345808c38bcab5ba5f422"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">使用 type parameter 和直接使用 interface 的区别</span></span></h2><blockquote id="https://www.notion.so/0797217e41b9417492850bb701dbd62a" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">参考：https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#values-of-type-parameters-are-not-boxed</span></span></blockquote><div id="https://www.notion.so/9e9306d13216420ab2099d0307e1c01f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Go 的泛型由于类型约束的存在，看上去会和 interface 类似，在这里与 interface 的主要不同是相关函数的返回值可以是具体的类型，而不只是 interface 。</span></span></p></div><div id="https://www.notion.so/57c27c57ab5d4184877ffdcf92573ade" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">用上面的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Add</code></span><span class="SemanticString"> 举例子，删除其类型参数则变成：</span></span></p></div><pre id="https://www.notion.so/b3d65c5dee374bf997d9465e41d4295e" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>func Add(a, b interface{}) interface{} {
        n, _ := a.(int)
        m, _ := b.(int)
        return n + m
}
</span></span></span></code></pre><div id="https://www.notion.so/9a0af29572d3402c967aad2c92ff1eca" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Add</code></span><span class="SemanticString">使用上述实现，调用方得到的返回值只能是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">interface</code></span><span class="SemanticString"> 或某一个特定的类型，而不能根据调用方的需求返回特定类型。如果返回的是</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">interface</code></span><span class="SemanticString">，调用方想得到返回值的具体类型，还需要进行拆箱 (unboxing) 操作，如：</span></span></p></div><pre id="https://www.notion.so/91ad4a2b8c8c4456a0796ddff4f5b6e3" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>func main() {
        a, b := 1, 2
        c := Add(a, b)
        d, ok := c.(int)
        ...
}
</span></span></span></code></pre><div id="https://www.notion.so/ddc130e9cf7047a3af1ae62f56581eb3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">同时，回忆一下 Go 中 interface 实例是如何构造的，一个interface里包含了两个值，代表其指向元素的type和value，构造 interface 实例，即装箱 (boxing) ，这会带来额外的内存开销，泛型可以避免这个内存开销。</span></span></p></div><h1 id="https://www.notion.so/f5372442b01d4055a347ceb15ccaa0c3" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/f5372442b01d4055a347ceb15ccaa0c3"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">类型推断</span></span></h1><div id="https://www.notion.so/48060560d2a842b290e6398f0979bcb9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">并不是每次调用支持泛型的函数都需要传入类型参数的，在一些条件下，类型推断可以推断出缺失的类型参数，这个技术被叫做类型推断。注意类型推断并不验证推断出的类型是否能通过编译，该检查在推断结束后进行。</span></span></p></div><div id="https://www.notion.so/088fd18264b1464a982a0e3ff55e39fc" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">接下来会介绍类型推断的 3 个知识点，并在最后介绍完整的类型推断流程。</span></span></p></div><h2 id="https://www.notion.so/1e6ce83d79ba4356b2fc1aa62f49b562" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/1e6ce83d79ba4356b2fc1aa62f49b562"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">类型归一化 ( Type unification )</span></span></h2><blockquote id="https://www.notion.so/56a01409ea954791aa22d30534484e5b" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">参考：https://go.dev/ref/spec#Type_unification</span></span><div id="https://www.notion.so/4224d6b65733424ca32d2ea0ceb24dde" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">这个名词我瞎翻译的，ChatGPT 建议翻译这个为“类型统一”</span></span></p></div></blockquote><h3 id="https://www.notion.so/6e58cc214e8b4df68b0ae7f73a6e76c0" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/6e58cc214e8b4df68b0ae7f73a6e76c0"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">功能描述</span></span></h3><div id="https://www.notion.so/cf7988567601404285f8e2edcf89b59d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">输入</strong></span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/3624a142fbec4011932a3b475dc5b4c2" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">映射关系 P -&gt; A，P 代表类型参数，A 代表已知的类型实参。例如 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">func Add[T any](a, b T) T</code></span><span class="SemanticString">一个可能的映射关系是 T -&gt; int。</span></span></li><li id="https://www.notion.so/c113c7adc48a4af88a970cfd39d20ea9" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">两个类型，这两个类型可以带有类型参数，也可以不带。</span></span></li></ol><div id="https://www.notion.so/9c23cc8581004e78881b7b59208676bf" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">输出</strong></span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/9387a523888147818480ebdca00cbe5b" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">基于已知的映射关系，判断输入的两个类型是否有可能相等。</span></span></li></ol><h3 id="https://www.notion.so/c458186488914c0795d7d6d3bdfc5dca" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/c458186488914c0795d7d6d3bdfc5dca"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">具体操作</span></span></h3><ol class="NumberedListWrapper"><li id="https://www.notion.so/5dc7475c55ee4202988d49dab131b88c" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">不带有类型参数的类型，与比较类型必须等价，否则归一失败。</span></span><ol class="NumberedListWrapper"><li id="https://www.notion.so/1a4a2aa87396461a8a866ff8ed092fb1" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">两个类型相等自然等价。</span></span></li><li id="https://www.notion.so/ec6044787aef44059ec3f7d4b4f13866" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">如果两个类型是 channel 类型，忽略 channel 方向后类型相等，也可以判定为等价。</span></span></li><li id="https://www.notion.so/99bb2d4b29c640e09530962318379d27" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">如果两个类型的 underlying types 是一致的，那也可以判定为等价。</span></span></li></ol></li><li id="https://www.notion.so/82a01d044bc44ce085e97722a7f821c4" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">带有类型参数的类型，在不考虑类型参数的前提下，该类型与比较类型在结构上必须相等，否则归一失败。</span></span><ol class="NumberedListWrapper"><li id="https://www.notion.so/7d65749514ee4d028e47928a229e7729" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">例如 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">[]map[T1]T2</code></span><span class="SemanticString"> 和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">[]T3</code></span><span class="SemanticString"> 在结构上是一致的，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">T3</code></span><span class="SemanticString"> 可以被替换成 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">map[T1]T2</code></span><span class="SemanticString">，同理 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">[]map[T1]bool</code></span><span class="SemanticString"> 和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">[]map[string]T2</code></span><span class="SemanticString"> 在结构上也是一致的。</span></span></li><li id="https://www.notion.so/0e1011f4d2e54bccbcc923bfbbe422b1" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">例如 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">[]map[T1]T2</code></span><span class="SemanticString"> 和 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">int</code></span><span class="SemanticString">, </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">struct{}</code></span><span class="SemanticString">, </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">[]struct{}</code></span><span class="SemanticString"> 等类型在结构上不可能一致。</span></span></li></ol></li><li id="https://www.notion.so/917e1a043dec4337adf4b174ac930b44" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">如果匹配成功，且类型带有类型参数，便知道了新的 P&#x27; -&gt; A&#x27; 映射关系，将新的映射关系加入到原有的映射关系中。</span></span></li></ol><h2 id="https://www.notion.so/8a3b5498a94546799d93d2ac47e62c0d" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/8a3b5498a94546799d93d2ac47e62c0d"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">函数实参类型推断 ( Function argument type inference )</span></span></h2><blockquote id="https://www.notion.so/3f0a2e7ab10742e398281f541405bd6e" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">参考：</span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/aae327413e4f4d04a9cdfe6f12495fc3" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#function-argument-type-inference</span></span></li><li id="https://www.notion.so/8385b1ffe07e4415ac931f93bbbb6fed" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">https://go.dev/ref/spec#Function_argument_type_inference</span></span></li></ul></blockquote><h3 id="https://www.notion.so/58380d8f707349a9bb723c982b0f8018" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/58380d8f707349a9bb723c982b0f8018"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">功能描述</span></span></h3><ol class="NumberedListWrapper"><li id="https://www.notion.so/222a54a6b98d4c44bc1f689a6c321b02" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">在调用有类型参数的函数时，若调用方没有传入类型参数，则根据实参推断出类型参数。</span></span></li></ol><h3 id="https://www.notion.so/8b35820984024950a32693ed61171114" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/8b35820984024950a32693ed61171114"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">具体实现</span></span></h3><ol class="NumberedListWrapper"><li id="https://www.notion.so/835eb2ac0fd14055b9b96765a3b8fd86" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">根据调用方传入实参得到一组 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">(parameter, argument)</code></span><span class="SemanticString">，即参数到实参的组合。</span></span></li><li id="https://www.notion.so/b0d8111acadc47a4892bbc01489fb302" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">先忽略 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">argument</code></span><span class="SemanticString"> 中没有类型的组合，没有类型即为常量，常量有自身的类型推断规则；对有类型的</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">(parameter, argument)</code></span><span class="SemanticString">组合，对其对应的类型进行类型归一化，并不断更新映射关系 P -&gt; A。</span></span></li><li id="https://www.notion.so/57fd1d76438f4557b4bae15afe0a8be7" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">接下来处理常量的</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">(parameter, argument)</code></span><span class="SemanticString">组合，如果一个组合中</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">parameter</code></span><span class="SemanticString">对应的类型参数已经在步骤 3 中被推断出来，那么忽略；如果没有，认定常量</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">argument</code></span><span class="SemanticString">的取值为该常量对应的默认类型，进行类型归一化。</span></span></li><li id="https://www.notion.so/eea8722c31b1457b8a157ef102497c9f" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">当所有</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">(parameter, argument)</code></span><span class="SemanticString">都被处理完成后，推断结束，中途若发生处理失败的情况，则推断失败。</span></span></li></ol><div id="https://www.notion.so/66b985bf343a401fa8993fb6f42b6971" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">接下来用一个示例描述上述步骤：</span></span></p></div><pre id="https://www.notion.so/fb99e0e8d4c04c28a4ecd76305422579" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>func scale[Number ~int64|~float64|~complex128](v []Number, s Number) []Number {
        ...
}

func main() {
        var vector []float64
        scaledVector := scale(vector, 42)
        ...
}
</span></span></span></code></pre><div id="https://www.notion.so/09fd9dfc22d04683af9d923a08b41570" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">函数实参类型推断开始时，得到两个</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">(parameter, argument)</code></span><span class="SemanticString">组合：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/61c1da43d5e44bd1b06e893d6b1c042b" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">(v []Number, vector []float64)</code></span></span></li><li id="https://www.notion.so/5d88d7a15c43416c9fa5c0540f7004b5" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">(s Number, 42)</code></span></span></li></ol><div id="https://www.notion.so/5165194cfe1841e59d70047fa2a3f3c9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">先对</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">(v []Number, vector []float64)</code></span><span class="SemanticString">的类型进行类型归一化，得到映射关系</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Number -&gt; float64</code></span><span class="SemanticString">。</span></span></p></div><div id="https://www.notion.so/f67d9367cb3149e8b00ba59d33a0759d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">因为上面已经推断出了映射关系</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Number -&gt; float64</code></span><span class="SemanticString">，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">(s Number, 42)</code></span><span class="SemanticString">组合就不必进行类型归一化。</span></span></p></div><div id="https://www.notion.so/f99d92ca5bb443fd90a866eaa87fdfb9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果没有映射关系</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Number -&gt; float64</code></span><span class="SemanticString">，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">(s Number, 42)</code></span><span class="SemanticString">中 42 的类型会被认定为默认类型 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">int</code></span><span class="SemanticString">，那么映射关系则为</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Number -&gt; int</code></span><span class="SemanticString">。</span></span></p></div><h2 id="https://www.notion.so/d2f2b1008f9d4af08960a69efa887ee2" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/d2f2b1008f9d4af08960a69efa887ee2"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">约束类型推断 ( Constraint type inference )</span></span></h2><blockquote id="https://www.notion.so/f946cb7cf6a24cb2af2699cb7c9bf340" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">参考：https://go.dev/ref/spec#Constraint_type_inference</span></span></blockquote><h3 id="https://www.notion.so/9d73782a06d64f54bb80f9f8e2266ea5" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/9d73782a06d64f54bb80f9f8e2266ea5"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">功能描述</span></span></h3><ol class="NumberedListWrapper"><li id="https://www.notion.so/3c098b261ad440978bc7f2511f4a56ba" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">根据定义的类型参数约束，从一个已知类型参数推导出其他暂时未知的类型参数。</span></span></li><li id="https://www.notion.so/32e8055f24be4d1db47b186d600fd3ee" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">例如有一个函数 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">func Double[S ~[]E, E constraints.Integer] (s S) S</code></span><span class="SemanticString"> ，这个函数被这样调用 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Double([]int{1, 2, 3})</code></span><span class="SemanticString">，可以从类型约束</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">S ~[]E</code></span><span class="SemanticString">和</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">S -&gt; []int</code></span><span class="SemanticString"> ，推断出</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">E -&gt; int</code></span><span class="SemanticString">。</span></span></li></ol><h3 id="https://www.notion.so/b08cfb17587e4f5e83712adc88600d0e" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/b08cfb17587e4f5e83712adc88600d0e"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">具体实现</span></span></h3><ol class="NumberedListWrapper"><li id="https://www.notion.so/9f1741b62ea14580bbb76c47d6b52d01" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">遍历所有类型参数</span></span><ol class="NumberedListWrapper"><li id="https://www.notion.so/6bccd84638b0491e805e084e31285ecb" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">如果类型参数已有对应的实参，对两者的 underlying type 进行归一化，如</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Double</code></span><span class="SemanticString">的例子中，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">S</code></span><span class="SemanticString">的 underlying type 是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">[]E</code></span><span class="SemanticString">，则对</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">[]E</code></span><span class="SemanticString">和已知实参</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">[]int</code></span><span class="SemanticString">进行归一化，推断出</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">E -&gt; int</code></span><span class="SemanticString">。</span></span></li><li id="https://www.notion.so/ca5b744ce34d4f68b18b2ac870dd65cb" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">如果类型参数没有对应的实参，但类型参数的类型约束只有一个类型，那么推断该类型参数对应的实参为约束类型。</span></span></li></ol></li><li id="https://www.notion.so/23a5c14a507740f88248b9252c491fcb" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">在已知的映射关系中，检查是否存在一组 P -&gt; A 和 Q -&gt; B 关系，其中 A 中包含了类型参数 Q，用 B 替换 A 中的 Q。例如</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">func Copy[T any, P *T](value T, dst P)</code></span><span class="SemanticString">，已知 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">T -&gt; int</code></span><span class="SemanticString">，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">P -&gt; *T</code></span><span class="SemanticString">，那么可以推断出</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">P -&gt; *int</code></span><span class="SemanticString">。</span></span></li><li id="https://www.notion.so/cfdc78bc3f4547089afaf833ea6369d1" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">重复步骤 2，直到已知的映射关系中再也找不到一个类型参数 P 被某个类型实参 A 包含。</span></span></li></ol><h2 id="https://www.notion.so/6f3daefb14bc4e59b06987554892177e" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/6f3daefb14bc4e59b06987554892177e"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">类型推断执行步骤</span></span></h2><blockquote id="https://www.notion.so/7b129fa41b43458fa8d274d960e85783" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">参考：https://github.com/golang/go/blob/go1.18/src/cmd/compile/internal/types2/infer.go#L33</span></span></blockquote><div id="https://www.notion.so/b565c8b220474f90ab6ca06fb7ba0b73" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">根据代码注释我们可以知道具体执行步骤如下：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/0ec8b68bc55141b7a028d7556db26a5a" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">利用类型实参进行函数实参类型推断。</span></span></li><li id="https://www.notion.so/65b7e0332e0d4bcd91570b3a97cefeda" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">再进行一次约束类型推断。</span></span></li><li id="https://www.notion.so/ce584011e6704a119bad6c1fc9f95419" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">对剩下无类型实参进行函数实参类型推断。</span></span></li><li id="https://www.notion.so/889ef778f5984e7d88c7d7fa3be4db5f" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">最后进行一次约束类型推断。</span></span></li></ol><div id="https://www.notion.so/becd108809874567922befb4fec32912" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">举一个例子：</span></span></p></div><pre id="https://www.notion.so/c37346a17ecb45448727ed792979f9c6" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>package main

import &quot;fmt&quot;
import &quot;golang.org/x/exp/constraints&quot;

func Multiple[S ~[]E, E, X constraints.Integer](s S, x X) S {
        for i, e := range s {
                s[i] *= x
        }
        return s
}

type IntVector []int

func main() {
        vector := IntVector{0, 1, 2, 3, 4}
        vector = Multiple(vector, 3)
        fmt.Printf(&quot;%s\n&quot;, vector)
        // output: [0, 3, 6, 9, 12]
}
</span></span></span></code></pre><div id="https://www.notion.so/951386deeb91413c81d27d2c0ccd4e32" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Multiple</code></span><span class="SemanticString">函数类型推断的步骤如下：</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/85a14b45d1224621851369edbb4254f2" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">对有类型的函数实参进行类型推断，即对</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">(s S, vector IntVector)</code></span><span class="SemanticString">进行类型推断，得到：</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">S -&gt; IntVector</code></span><span class="SemanticString">。</span></span></li><li id="https://www.notion.so/fe164fcb070941d5a171d0f8d0ea2cd9" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">进行约束类型推断，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">S</code></span><span class="SemanticString">的约束为</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">[]E</code></span><span class="SemanticString">，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">IntVector</code></span><span class="SemanticString">的underlying type 为</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">[]int</code></span><span class="SemanticString">，则对</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">[]E, []int</code></span><span class="SemanticString">进行类型归一化，得到</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">E -&gt; int</code></span><span class="SemanticString">。</span></span></li><li id="https://www.notion.so/31165cf3c4e74b16bb0fe4d4c5160d62" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">对无类型函数实参进行类型推断，即对</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">(x X, 3)</code></span><span class="SemanticString">进行类型推断，对常量 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">3</code></span><span class="SemanticString">取默认值 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">int</code></span><span class="SemanticString">，得到</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">X -&gt; int</code></span><span class="SemanticString">。</span></span></li><li id="https://www.notion.so/db83e68c8b78400f89317abf3740a0af" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">再次进行约束类型推断，但因为所有参数类型已知，提前结束。</span></span></li></ol><h1 id="https://www.notion.so/0fee66bdfcd34ef88358650f74599c60" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/0fee66bdfcd34ef88358650f74599c60"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">其他</span></span></h1><div id="https://www.notion.so/83fd55ec11e040aa86a14063de7b93d7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">一些其他相关内容整理</span></span></p></div><h2 id="https://www.notion.so/10606d83443b4478bec92dc6b85ddf3a" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/10606d83443b4478bec92dc6b85ddf3a"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">泛型窘境</span></span></h2><blockquote id="https://www.notion.so/7d02185f99574dc4a8e79045e79bd237" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">参考：https://research.swtch.com/generic</span></span></blockquote><div id="https://www.notion.so/ca63cd4d0568467095b5ebf708fef869" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在一个编程语言中添加泛型，势必会增加下列三方中至少一方的复杂度：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/f30394b84d15458a9f0e81c9a33c5db2" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">程序员，C 语言采用了这种方法，即只支持泛型语法，但编译器和运行时都不考虑泛型带来的问题，如有问题程序员自己排查。</span></span></li><li id="https://www.notion.so/cc4ce02aebd54c40a85e91ca26f71888" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">编译，C++ 采用了这种方法，在编译时推断出类型，运行时泛型已不存在，这会增加编译耗时以及增加编译产物的数据大小。</span></span></li><li id="https://www.notion.so/d2d934b76cdf442b9608d8ea43a0628d" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">运行时，Java 采用了这种方法，在运行时携带参数的类型信息，这会降低运行时的效率，针对 Java，这也引入了类型擦除问题（有兴趣可自行了解）。</span></span></li></ul><div id="https://www.notion.so/b302b8e7207442058320fdb5058b1528" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">由前文可以看出，Go 采取的是增加编译耗时，编译时就推断出了一个方法需要的全部类型信息。</span></span></p></div><h2 id="https://www.notion.so/2dc6e69262dd4149b2ce1c026cdf8ed8" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/2dc6e69262dd4149b2ce1c026cdf8ed8"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">使用 [T] 而不是 &lt;T&gt;</span></span></h2><div id="https://www.notion.so/e73a02b279a448afba26df898adef7a1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">相信很多同学对泛型的第一印象都是 C++ 或 Java 中的 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">&lt;T&gt;</code></span><span class="SemanticString">语法，https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#why-not-use-the-syntax-like-c_and-java 中解释了 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">&lt;</code></span><span class="SemanticString">和</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">&gt;</code></span><span class="SemanticString">两个符号因为也用做比较符号，区分</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">&lt;</code></span><span class="SemanticString">和</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">&gt;</code></span><span class="SemanticString">是在表示比较还是类型参数会带来额外的负担，故最后选择了 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">[T]</code></span></span></p></div><h2 id="https://www.notion.so/9b27a71f154446e0ae56c5101e2f17d4" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/9b27a71f154446e0ae56c5101e2f17d4"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">为何 Go 泛型不支持 method？</span></span></h2><blockquote id="https://www.notion.so/008b787182c04f0e85cb4d1913e4b788" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">本段说明略跳跃和简短，更详细的说明和示例请参考：https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md#no-parameterized-methods</span></span></blockquote><div id="https://www.notion.so/4249033c58114e4d86c697b58a5ce706" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在 Go 中，结构体可以使用类型参数，但一个结构体的方法是不被允许使用类型参数的，最主要的原因是因为 Go interface 的特性所致。上文有提到，interface 可以表达“方法的集合”，即一个 interface 可以代表所有实现了其定义方法的结构体。假设说 method 支持泛型，那会出现如下的 interface 定义：</span></span></p></div><pre id="https://www.notion.so/3bd5ead7942149e7b0d5d612c4ed6073" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>type Phone interface {
        Call[N PhoneNumber](n N)
        Download[A App](a A)
}
</span></span></span></code></pre><div id="https://www.notion.so/d3216442761b4261946cbfdebb838e9a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">同时考虑到 Go 的 interface 和结构体之间没有显式的关系定义，即不存在类似</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">struct iPhone extend Phone</code></span><span class="SemanticString">这样的语法。因此确定一个 interface 下各个方法的类型参数，以及确定一个类型是否符合一个 interface 会需要大量的类型推断，会给带来非常大的工作量和编译损耗。</span></span></p></div><h2 id="https://www.notion.so/adc0663a13124a89b748de4cbafdee7e" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/adc0663a13124a89b748de4cbafdee7e"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">支持指针方法</span></span></h2><div id="https://www.notion.so/6e0b828618544bff957101e157395f55" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">当我们定义了一个泛型函数 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">F[T C]</code></span><span class="SemanticString">，相应类型参数的约束 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">C</code></span><span class="SemanticString">定义了一些方法，向这个函数传入类型 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">c</code></span><span class="SemanticString">时，如果</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">C</code></span><span class="SemanticString">中定义的各种方法被定义在了</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">*c</code></span><span class="SemanticString">类型而不是 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">c</code></span><span class="SemanticString">上，此时代码将无法编译。</span></span></p></div><div id="https://www.notion.so/3922e6e385d34dc0bd06bd453a15d248" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">举一个具体例子：</span></span></p></div><pre id="https://www.notion.so/b3a0523ea61549d09dedd0cc5f02d648" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>type Setter interface {
        Set(string)
}

func FromStrings[T Setter](s []string) []T {
        result := make([]T, len(s))
        for i, v := range s {
                result[i].Set(v)
        }
        return result
}

type Settable int

func (p *Settable) Set(s string) {
        i, _ := strconv.Atoi(s) // real code should not ignore the error
        *p = Settable(i)
}

func F() {
        // INVALID
        nums := FromStrings[Settable]([]string{&quot;1&quot;, &quot;2&quot;})
        // Here we want nums to be []Settable{1, 2}.
        ...
}
</span></span></span></code></pre><div id="https://www.notion.so/c715d0487b084896bd94dba842b6e058" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">上面的例子中，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">result</code></span><span class="SemanticString">的类型为</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">[]Settable</code></span><span class="SemanticString">，而</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Settable</code></span><span class="SemanticString">并不支持 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Set</code></span><span class="SemanticString"> 方法，支持</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Set</code></span><span class="SemanticString">方法的是</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">*Settable</code></span><span class="SemanticString">，故</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">result[i].Set(v)</code></span><span class="SemanticString">无法正常调用。</span></span></p></div><div id="https://www.notion.so/66f52ddd27a54673a7083643403d5382" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">相应的解法如下：</span></span></p></div><pre id="https://www.notion.so/f1e318f0affa45a287f605a16723aa5c" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>type Setter2[B any] interface {
        Set(string)
        *B // non-interface type constraint element
}

func FromStrings2[T any, PT Setter2[T]](s []string) []T {
        result := make([]T, len(s))
        for i, v := range s {
                // The type of &amp;result[i] is *T which is in the type set
                // of Setter2, so we can convert it to PT.
                p := PT(&amp;result[i])
                // PT has a Set method.
                p.Set(v)
        }
        return result
}
</span></span></span></code></pre><div id="https://www.notion.so/5b78aff1b11e4111a08860d9462ac6df" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">即在泛型函数中明确区分出类型</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">T</code></span><span class="SemanticString">和其对应的指针类型 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">PT</code></span><span class="SemanticString">，并通过类型约束</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Setter2[B any]</code></span><span class="SemanticString">定义其之间的转化关系，调用</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Set</code></span><span class="SemanticString">时转换类型，调用成功。</span></span></p></div><h2 id="https://www.notion.so/8be1cdcb85b24e16b7e344733c5c818d" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/8be1cdcb85b24e16b7e344733c5c818d"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">在工作中使用泛型</span></span></h2><div id="https://www.notion.so/1fc3b9ff40bc4e94b3d9929c02a5d01b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">以上，我们从 Go 的类型约束出发，了解了定义泛型函数需要的知识点，并了解了类型推断的关键点，最后我们讨论下在泛型在工作中的应用：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/fbae4e14b8a240e2b06a0c479387e6b8" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">容器操作。</span></span></li><li id="https://www.notion.so/412b6e5e2b444c518ffe639763beeedb" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">通用数据结构。</span></span></li><li id="https://www.notion.so/10179c0a108843c389119259d7cf4fdf" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">通用操作逻辑，自己日常维护的代码中有请求数据网关服务的操作，由于数据网关返回的数据是一个固定的结构体，使用相对比较麻烦，自己用泛型对请求和返回进行了封装，使不同数据源返回的数据可以转化为特定的结构体。</span></span></li></ul><div id="https://www.notion.so/2f85118fae6241a295f260d0e61e0968" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">如果你在工作中有其他的泛型使用方法，或者有其他好用的泛型库推荐，欢迎评论补充 : )</span></span></p></div><h1 id="https://www.notion.so/b1cc464f72e849ac86d8a2a9deceef22" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/b1cc464f72e849ac86d8a2a9deceef22"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">类型推断代码</span></span></h1><h2 id="https://www.notion.so/445e764cc9574855b17a4b5e69faabfc" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/445e764cc9574855b17a4b5e69faabfc"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">类型归一化</span></span></h2><blockquote id="https://www.notion.so/e97c47041f4f41bd8105b0a39cc5e267" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">参考：https://github.com/golang/go/blob/go1.18/src/cmd/compile/internal/types2/unify.go</span></span></blockquote><div id="https://www.notion.so/77ceb17c276143888921a5447aa5603a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">不断递归判断</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">x, y Type</code></span><span class="SemanticString">在映射关系</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">p * ifacePair</code></span><span class="SemanticString">下是否有可能相等，如果发现</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">x</code></span><span class="SemanticString">或</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">y</code></span><span class="SemanticString">为没有推断出的类型参数，则匹配并返回相等。</span></span></p></div><pre id="https://www.notion.so/fc2a6e1cba834e34b16ca05fc2cb4e87" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>// nify implements the core unification algorithm which is an
// adapted version of Checker.identical. For changes to that
// code the corresponding changes should be made here.
// Must not be called directly from outside the unifier.
func (u *unifier) nify(x, y Type, p *ifacePair) (result bool) {

        ......

        // Cases where at least one of x or y is a type parameter.
        switch i, j := u.x.index(x), u.y.index(y); {
        case i &gt;= 0 &amp;&amp; j &gt;= 0:
                // both x and y are type parameters
                if u.join(i, j) {
                        return true
                }
                // both x and y have an inferred type - they must match
                return u.nifyEq(u.x.at(i), u.y.at(j), p)

        case i &gt;= 0:
                // x is a type parameter, y is not
                if tx := u.x.at(i); tx != nil {
                        return u.nifyEq(tx, y, p)
                }
                // otherwise, infer type from y
                u.x.set(i, y)
                return true

        case j &gt;= 0:

                ......

        }

        ......

        switch x := x.(type) {

        ......

        case *Slice:
                // Two slice types are identical if they have identical element types.
                if y, ok := y.(*Slice); ok {
                        return u.nify(x.elem, y.elem, p)
                }

        case *Struct:
                // Two struct types are identical if they have the same sequence of fields,
                // and if corresponding fields have the same names, and identical types,
                // and identical tags. Two embedded fields are considered to have the same
                // name. Lower-case field names from different packages are always different.
                if y, ok := y.(*Struct); ok {
                        if x.NumFields() == y.NumFields() {
                                for i, f := range x.fields {
                                        g := y.fields[i]
                                        if f.embedded != g.embedded ||
                                                x.Tag(i) != y.Tag(i) ||
                                                !f.sameId(g.pkg, g.name) ||
                                                !u.nify(f.typ, g.typ, p) {
                                                return false
                                        }
                                }
                                return true
                        }
                }

        ......

        default:
                panic(sprintf(nil, true, &quot;u.nify(%s, %s), u.x.tparams = %s&quot;, x, y, u.x.tparams))
        }

        return false
}
</span></span></span></code></pre><h2 id="https://www.notion.so/5106e64fcc6d411598613b707bc91b2f" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/5106e64fcc6d411598613b707bc91b2f"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">函数实参类型推断</span></span></h2><h3 id="https://www.notion.so/3c39dd4765cd4c09afeb45b9f14fdd84" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/3c39dd4765cd4c09afeb45b9f14fdd84"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">有类型的实参直接归一化</span></span></h3><blockquote id="https://www.notion.so/e2353d1591e940e990f4e8e1fe5e6358" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">参考：https://github.com/golang/go/blob/go1.18/src/cmd/compile/internal/types2/infer.go#L250</span></span></blockquote><pre id="https://www.notion.so/0f67c6f9bade4d5f80ee23818cc9dbbe" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>        // indices of the generic parameters with untyped arguments - save for later
        var indices []int
        for i, arg := range args {
                par := params.At(i)
                // If we permit bidirectional unification, this conditional code needs to be
                // executed even if par.typ is not parameterized since the argument may be a
                // generic function (for which we want to infer its type arguments).
                if isParameterized(tparams, par.typ) {
                        if arg.mode == invalid {
                                // An error was reported earlier. Ignore this targ
                                // and continue, we may still be able to infer all
                                // targs resulting in fewer follow-on errors.
                                continue
                        }
                        if targ := arg.typ; isTyped(targ) {
                                // If we permit bidirectional unification, and targ is
                                // a generic function, we need to initialize u.y with
                                // the respective type parameters of targ.
                                if !u.unify(par.typ, targ) {
                                        errorf(&quot;type&quot;, par.typ, targ, arg)
                                        return nil
                                }
                        } else if _, ok := par.typ.(*TypeParam); ok {
                                // Since default types are all basic (i.e., non-composite) types, an
                                // untyped argument will never match a composite parameter type; the
                                // only parameter type it can possibly match against is a *TypeParam.
                                // Thus, for untyped arguments we only need to look at parameter types
                                // that are single type parameters.
                                indices = append(indices, i)
                        }
                }
        }

</span></span></span></code></pre><h3 id="https://www.notion.so/28847dbd2a114004844fb10507f7007e" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/28847dbd2a114004844fb10507f7007e"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">没有类型的实参赋予常量默认值后归一化</span></span></h3><blockquote id="https://www.notion.so/8d644c84c3c444f5a4e28c4fb757fc33" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">参考：https://github.com/golang/go/blob/go1.18/src/cmd/compile/internal/types2/infer.go#L297</span></span></blockquote><pre id="https://www.notion.so/b68bc3e38ff14b9581dd693923fb93d6" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>        // Use any untyped arguments to infer additional type arguments.
        // Some generic parameters with untyped arguments may have been given
        // a type by now, we can ignore them.
        for _, i := range indices {
                tpar := params.At(i).typ.(*TypeParam) // is type parameter by construction of indices
                // Only consider untyped arguments for which the corresponding type
                // parameter doesn&#x27;t have an inferred type yet.
                if targs[tpar.index] == nil {
                        arg := args[i]
                        targ := Default(arg.typ)
                        // The default type for an untyped nil is untyped nil. We must not
                        // infer an untyped nil type as type parameter type. Ignore untyped
                        // nil by making sure all default argument types are typed.
                        if isTyped(targ) &amp;&amp; !u.unify(tpar, targ) {
                                errorf(&quot;default type&quot;, tpar, targ, arg)
                                return nil
                        }
                }
        }

</span></span></span></code></pre><h2 id="https://www.notion.so/8fc2874de25645778c0d727ce68db288" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/8fc2874de25645778c0d727ce68db288"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">约束类型推断</span></span></h2><blockquote id="https://www.notion.so/040d61add4f741308d807941056534d5" class="ColorfulBlock ColorfulBlock--ColorDefault Quote"><span class="SemanticStringArray"><span class="SemanticString">参考：https://github.com/golang/go/blob/go1.18/src/cmd/compile/internal/types2/infer.go#L468</span></span></blockquote><h3 id="https://www.notion.so/a729c85939ab4a3a8cfa5d695cff3ac9" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/a729c85939ab4a3a8cfa5d695cff3ac9"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">类型参数 core type 处理</span></span></h3><div id="https://www.notion.so/fd93d85442994593be3ee36838645450" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在约束类型推断的一阶段，引入了一个新概念 core type，本文不做过多介绍，可以理解为类型约束对应约束类型的 underlying type。利用 core type 与已知实参可以完成一些类型推断。</span></span></p></div><pre id="https://www.notion.so/6347e16477714e1e97e424172cad2702" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>                for i, tpar := range tparams {
                        // If there is a core term (i.e., a core type with tilde information)
                        // unify the type parameter with the core type.
                        if core, single := coreTerm(tpar); core != nil {
                                // A type parameter can be unified with its core type in two cases.
                                tx := u.x.at(i)
                                switch {
                                case tx != nil:

                                        ......

                                        if !u.unify(tx, core.typ) {
                                                // TODO(gri) improve error message by providing the type arguments
                                                //           which we know already
                                                // Don&#x27;t use term.String() as it always qualifies types, even if they
                                                // are in the current package.
                                                tilde := &quot;&quot;
                                                if core.tilde {
                                                        tilde = &quot;~&quot;
                                                }
                                                check.errorf(pos, &quot;%s does not match %s%s&quot;, tpar, tilde, core.typ)
                                                return nil, 0
                                        }

                                case single &amp;&amp; !core.tilde:
                                        // The corresponding type argument tx is unknown and there&#x27;s a single
                                        // specific type and no tilde.
                                        // In this case the type argument must be that single type; set it.
                                        u.x.set(i, core.typ)

                                default:
                                        // Unification is not possible and no progress was made.
                                        continue
                                }

                                ......

                        }
                }
</span></span></span></code></pre><h3 id="https://www.notion.so/b00bef1d33e0426b941899c9b3383084" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--3"><a class="Anchor" href="#https://www.notion.so/b00bef1d33e0426b941899c9b3383084"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">映射关系化简</span></span></h3><div id="https://www.notion.so/0010810aad0e41b68836a42e9c7e9909" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">约束类型推断的二阶段，不断化简映射关系。</span></span></p></div><pre id="https://www.notion.so/3339250780af4223a55dde0c4557365d" class="Code"><code><span class="SemanticStringArray"><span class="SemanticString"><span>                smap := makeSubstMap(tparams, types)
                n := 0
                for _, index := range dirty {
                        t0 := types[index]
                        if t1 := check.subst(nopos, t0, smap, nil); t1 != t0 {
                                types[index] = t1
                                dirty[n] = index
                                n++
                        }
                }
</span></span></span></code></pre></article>
  <footer class="Footer">
</footer>
</body>

</html>